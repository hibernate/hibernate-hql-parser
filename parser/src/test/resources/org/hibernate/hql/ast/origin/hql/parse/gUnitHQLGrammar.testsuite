gunit HQL;

@header{
package org.hibernate.hql.ast.origin.hql.parse;
}


statement:

/*
SELECT/FROM STATEMENT
*/
[testSimpleFrom]
"from com.example.EntityName e"  OK
[testConstantUsage]
"from com.example.EntityName where prop = org.hibernate.query.ast.phase.hql.parse.ParserTest.CONSTANT"  OK
"from com.example.EntityName where prop = compProp.subProp"  OK
[testVariousPropertyReferences]
"from A a where b = 1"  OK
"from A a where a.b.c = 1"  OK
"from X x where y[1].z = 2"  OK
"from X x where x.y[1].z = 2"  OK
[testEntityNamePathWithKeyword]
"from org.hibernate.test.Inner"  OK
[testWhereClauseIdentPrimaryWithEmbeddedKeyword]
"from org.hibernate.test.Inner i where i.outer.inner.middle = 'xyz'"  OK
[testDynamicInstantiation]
"select new list(a, mate) from Animal a join a.mate as mate"  OK
"from Animal join a.mate"  OK
"from Animal, aaa , dddd"  OK
"from Animal, aaa join fetch dddd" OK
[testListOrMapKeywordReference]
"select p from eg.NameList nl, eg.Person p where p.name = some elements(nl.names)"  OK
"select p from eg.NameList list, eg.Person p where p.name = some elements(list.names)"  OK
"select p from eg.NameList map, eg.Person p where p.name = some elements(map.names)"  OK
[testExplicitPropertyJoin]
"from eg.Cat as cat inner join fetch cat.mate as m fetch all properties left join fetch cat.kittens as k"  OK
[ tests copied over from org.hibernate.test.hql.HqlParserTest ~~~~~~~~~~~~]
"from Animal a where a in (from Cat union from Dog)"  OK
 [Section 9.2 - from]
"from eg.Cat"  OK
"from eg.Cat as cat"  OK
"from eg.Cat cat"  OK
"from Formula, Parameter"  OK
"from Formula as form, Parameter as param"  OK
[Section 9.3 - Associations and joins]
"from eg.Cat as cat inner join cat.mate as mate left outer join cat.kittens as kitten"  OK
"from eg.Cat as cat left join cat.mate.kittens as kittens"  OK
"from Formula form full join form.parameter param"  OK
"from eg.Cat as cat join cat.mate as mate left join cat.kittens as kitten"  OK
"from eg.Cat as cat inner join fetch cat.mate left join fetch cat.kittens"  OK
[Section 9.4 - Select]
"select mate from eg.Cat as cat inner join cat.mate as mate"  OK
"select cat.mate from eg.Cat cat"  OK
"select elements(cat.kittens) from eg.Cat cat"  OK
"select cat.name from eg.DomesticCat cat where cat.name like 'fri%'"  OK
"select cust.name.firstName from Customer as cust"  OK
"select mother, offspr, mate.name from eg.DomesticCat  as mother inner join mother.mate as mate left outer join mother.kittens as offspr"  OK
"select new Family(mother, mate, offspr) from eg.DomesticCat as mother join mother.mate as mate left join mother.kittens as offspr"  OK
[Section 9.5 - Aggregate functions]
"select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat) from eg.Cat cat"  OK
"select cat, count( elements(cat.kittens) ) from eg.Cat cat group by cat"  OK
"select distinct cat.name from eg.Cat cat"  OK
"select count(distinct cat.name), count(cat) from eg.Cat cat"  OK
[Section 9.6 - Polymorphism]
"from java.lang.Object o"  OK
"from eg.Named n, eg.Named m where n.name = m.name"  OK
[Section 9.7 - Where]
"from eg.Cat as cat where cat.name='Fritz'"  OK
"select foo from eg.Foo foo, eg.Bar bar where foo.startDate = bar.date"  OK
"from eg.Cat cat where cat.mate.name is not null"  OK
"from eg.Cat cat, eg.Cat rival where cat.mate = rival.mate"  OK
"select cat, mate from eg.Cat cat, eg.Cat mate where cat.mate = mate"  OK
"from eg.Cat as cat where cat.id = 123"  OK
"from eg.Cat as cat where cat.mate.id = 69"  OK
"from bank.Person person where person.id.country = 'AU' and person.id.medicareNumber = 123456"  OK
"from bank.Account account where account.owner.id.country = 'AU' and account.owner.id.medicareNumber = 123456"  OK
"from eg.Cat cat where cat.class = eg.DomesticCat"  OK
"from eg.AuditLog log, eg.Payment payment where log.item.class = 'eg.Payment' and log.item.id = payment.id"  OK
"from eg.Cat as cat where cat.name='Fritz' blah" FAIL
"from eg.Cat as cat where cat.name='Fritz' blah blah blah" FAIL
"from eg.Cat as cat where cat.name='Fritz' order by cat.age blah" FAIL
"from eg.Cat as cat where cat.name='Fritz' order by cat.age blah blah" FAIL
[Section 9.8 - Expressions]
"from eg.DomesticCat cat where cat.name between 'A' and 'B'"  OK
"from eg.DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )"  OK
"from eg.DomesticCat cat where cat.name not between 'A' and 'B'"  OK
"from eg.DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )"  OK
"from eg.Cat cat where cat.kittens.size > 0"  OK
"from eg.Cat cat where size(cat.kittens) > 0"  OK
//"from Calendar cal where cal.holidays.maxElement > current date"  OK
"from Order order where maxindex(order.items) > 100"  OK
"from Order order where minelement(order.items) > 10000"  OK
"from Order ord where maxindex(ord.items) > 100"  OK
"from Order ord where minelement(ord.items) > 10000"  OK
"select mother from eg.Cat as mother, eg.Cat as kit where kit in elements(foo.kittens)"  OK
"select p from eg.NameList list, eg.Person p where p.name = some elements(list.names)"  OK
"from eg.Cat cat where exists elements(cat.kittens)"  OK
"from eg.Player p where 3 > all elements(p.scores)"  OK
"from eg.Show show where 'fizard' in indices(show.acts)"  OK
"from Order order where order.items[0].id = 1234"  OK
"select person from Person person, Calendar calendar where calendar.holidays['national day'] = person.birthDay and person.nationality.calendar = calendar"  OK
"select item from Item item, Order order where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11"  OK
"select item from Item item, Order order where order.items[ maxindex(order.items) ] = item and order.id = 11"  OK
"from Order ord where ord.items[0].id = 1234"  OK
"select item from Item item, Order ord where ord.items[ ord.deliveredItemIndices[0] ] = item and ord.id = 11"  OK
"select item from Item item, Order ord where ord.items[ maxindex(ord.items) ] = item and ord.id = 11"  OK
"select item from Item item, Order ord where ord.items[ size(ord.items) - 1 ] = item"  OK
"from eg.DomesticCat cat where upper(cat.name) like 'FRI%'"  OK
"select cust from Product prod, Store store inner join store.customers cust where prod.name = 'widget' and store.location.name in ( 'Melbourne', 'Sydney' ) and prod = all elements(cust.currentOrder.lineItems)"  OK
[testDocoExamples99]
"from eg.DomesticCat cat order by cat.name asc, cat.weight desc, cat.birthdate"  OK
[testDocoExamples910]
"select cat.color, sum(cat.weight), count(cat) from eg.Cat cat group by cat.color"  OK
"select foo.id, avg( elements(foo.names) ), max( indices(foo.names) ) from eg.Foo foo group by foo.id"  OK
"select cat.color, sum(cat.weight), count(cat) from eg.Cat cat group by cat.color having cat.color in (eg.Color.TABBY, eg.Color.BLACK)"  OK
"select cat from eg.Cat cat join cat.kittens kitten group by cat having avg(kitten.weight) > 100 order by count(kitten) asc, sum(kitten.weight) desc"  OK
[testDocoExamples911]
"from eg.Cat as fatcat where fatcat.weight > (select avg(cat.weight) from eg.DomesticCat cat)"  OK
"from eg.DomesticCat as cat where cat.name = some (select name.nickName from eg.Name as name)"  OK
"from eg.Cat as cat where not exists (from eg.Cat as mate where mate.mate = cat)"  OK
"from eg.DomesticCat as cat where cat.name not in (select name.nickName from eg.Name as name)"  OK
[testDocoExamples912]
<<select ord.id, sum(price.amount), count(item)
  from Order as ord join ord.lineItems as item
  join item.product as product, Catalog as catalog
  join catalog.prices as price
  where ord.paid = false
  and ord.customer = :customer
  and price.product = product
  and catalog.effectiveDate < sysdate
  and catalog.effectiveDate >= all (
  select cat.effectiveDate from Catalog as cat where cat.effectiveDate < sysdate)
  group by ord
  having sum(price.amount) > :minAmount
  order by sum(price.amount) desc>> OK
<<select ord.id, sum(price.amount), count(item)
  from Order as ord join ord.lineItems as item join item.product as product,
  Catalog as catalog join catalog.prices as price
  where ord.paid = false and ord.customer = :customer
  and price.product = product and catalog = :currentCatalog
  group by ord having sum(price.amount) > :minAmount
  order by sum(price.amount) desc>> OK
<<select count(payment), status.name
  from Payment as payment
      join payment.currentStatus as status
      join payment.statusChanges as statusChange
  where payment.status.name <> PaymentStatus.AWAITING_APPROVAL
      or (
          statusChange.timeStamp = ( 
              select max(change.timeStamp) 
              from PaymentStatusChange change
              where change.payment = payment
          )
          and statusChange.user <> :currentUser
      )
  group by status.name, status.sortOrder
  order by status.sortOrder>>  OK
<<select count(payment), status.name 
  from Payment as payment
      join payment.currentStatus as status
  where payment.status.name <> PaymentStatus.AWAITING_APPROVAL
      or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :currentUser
  group by status.name, status.sortOrder
  order by status.sortOrder>>  OK
<<select account, payment
  from Account as account
      left outer join account.payments as payment
  where :currentUser in elements(account.holder.users)
      and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
  order by account.type.sortOrder, account.accountNumber, payment.dueDate>>  OK
<<select account, payment
  from Account as account
      join account.holder.users as user
      left outer join account.payments as payment
  where :currentUser = user
      and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
  order by account.type.sortOrder, account.accountNumber, payment.dueDate>>  OK
[testExamples1]
"select new org.hibernate.test.S(s.count, s.address) from s in class Simple"  OK
"select s.name, sysdate, trunc(s.pay), round(s.pay) from s in class Simple"  OK
"select abs(round(s.pay)) from s in class Simple"  OK
"select trunc(round(sysdate)) from s in class Simple"  OK
[testMultipleActualParameters]
"select round(s.pay, 2) from s"  OK
[testMultipleFromClasses]
"from eg.mypackage.Cat qat, com.toadstool.Foo f"  OK
"from eg.mypackage.Cat qat, org.jabberwocky.Dipstick"  OK
[testFromWithJoin]
"from eg.mypackage.Cat qat, com.toadstool.Foo f join net.sf.blurb.Blurb"  OK
"from eg.mypackage.Cat qat  left join com.multijoin.JoinORama , com.toadstool.Foo f join net.sf.blurb.Blurb"  OK
[testSelect]
"select f from eg.mypackage.Cat qat, com.toadstool.Foo f join net.sf.blurb.Blurb"  OK
"select distinct bar from eg.mypackage.Cat qat  left join com.multijoin.JoinORama as bar, com.toadstool.Foo f join net.sf.blurb.Blurb"  OK
"select count(*) from eg.mypackage.Cat qat"  OK
"select avg(qat.weight) from eg.mypackage.Cat qat"  OK
[testWhere]
"from eg.mypackage.Cat qat where qat.name like '%fluffy%' or qat.toes > 5"  OK
"from eg.mypackage.Cat qat where not qat.name like '%fluffy%' or qat.toes > 5"  OK
"from eg.mypackage.Cat qat where not qat.name not like '%fluffy%'"  OK
"from eg.mypackage.Cat qat where qat.name in ('crater','bean','fluffy')"  OK
"from eg.mypackage.Cat qat where qat.name not in ('crater','bean','fluffy')"  OK
[testGroupBy]
"from eg.mypackage.Cat qat group by qat.breed"  OK
"from eg.mypackage.Cat qat group by qat.breed, qat.eyecolor"  OK
[testOrderBy]
"from eg.mypackage.Cat qat order by avg(qat.toes)"  OK
"from Animal an order by sqrt(an.bodyWeight)/2"  OK
[testDoubleLiteral]
"from eg.Cat as tinycat where fatcat.weight < 3.1415"  OK
"from eg.Cat as enormouscat where fatcat.weight > 3.1415e3"  OK
[testComplexConstructor]
"select new Foo(count(bar)) from bar"  OK
"select new Foo(count(bar),(select count(*) from doofus d where d.gob = 'fat' )) from bar"  OK
[testInNotIn]
"from foo where foo.bar in ('a' , 'b', 'c')"  OK
"from foo where foo.bar not in ('a' , 'b', 'c')"  OK
[testOperatorPrecedence]
"from foo where foo.bar = 123 + foo.baz * foo.not"  OK
"from foo where foo.bar like 'testzzz' || foo.baz or foo.bar in ('duh', 'gob')"  OK
[testUnitTestHql]
"select foo from foo in class org.hibernate.test.Foo, fee in class org.hibernate.test.Fee where foo.dependent = fee order by foo.string desc, foo.component.count asc, fee.id"  OK
"select foo.foo, foo.dependent from foo in class org.hibernate.test.Foo order by foo.foo.string desc, foo.component.count asc, foo.dependent.id"  OK
"select foo from foo in class org.hibernate.test.Foo order by foo.dependent.id, foo.dependent.fi"  OK
"select one from one in class org.hibernate.test.One order by one.value asc"  OK
"select many.one from many in class org.hibernate.test.Many order by many.one.value asc, many.one.id"  OK
"select foo.id from org.hibernate.test.Foo foo where foo.joinedProp = 'foo'"  OK
"from org.hibernate.test.Foo foo inner join fetch foo.foo"  OK
"from org.hibernate.test.Baz baz left outer join fetch baz.fooToGlarch"  OK
"select foo.foo.foo.string from foo in class org.hibernate.test.Foo where foo.foo = 'bar'"  OK
"select foo.foo.foo.foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo = 'bar'"  OK
"select foo.foo.foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo.foo.string = 'bar'"  OK
"select foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo = 'bar' and foo.foo.foo.foo = 'baz'"  OK
"select foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo.foo.string = 'a' and foo.foo.string = 'b'"  OK
"from org.hibernate.test.Foo as foo where foo.component.glarch.name is not null"  OK
"from org.hibernate.test.Foo as foo left outer join foo.component.glarch as glarch where glarch.name = 'foo'"  OK
"from org.hibernate.test.Foo"  OK
"from org.hibernate.test.Foo foo left outer join foo.foo"  OK
"from org.hibernate.test.Foo, org.hibernate.test.Bar"  OK
"from org.hibernate.test.Baz baz left join baz.fooToGlarch, org.hibernate.test.Bar bar join bar.foo"  OK
"from org.hibernate.test.Baz baz left join baz.fooToGlarch join baz.fooSet"  OK
"from org.hibernate.test.Baz baz left join baz.fooToGlarch join fetch baz.fooSet foo left join fetch foo.foo"  OK
"from foo in class org.hibernate.test.Foo where foo.string='osama bin laden' and foo.boolean = true order by foo.string asc, foo.component.count desc"  OK
"from foo in class org.hibernate.test.Foo where foo.string='osama bin laden' order by foo.string asc, foo.component.count desc"  OK
"select foo.foo from foo in class org.hibernate.test.Foo"  OK
"from foo in class org.hibernate.test.Foo where foo.component.count is null order by foo.component.count"  OK
"from foo in class org.hibernate.test.Foo where foo.component.name='foo'"  OK
"select distinct foo.component.name, foo.component.name from foo in class org.hibernate.test.Foo where foo.component.name='foo'"  OK
"select distinct foo.component.name, foo.id from foo in class org.hibernate.test.Foo where foo.component.name='foo'"  OK
"from foo in class org.hibernate.test.Foo where foo.id=?"  OK
"from foo in class org.hibernate.test.Foo where foo.key=?"  OK
"select foo.foo from foo in class org.hibernate.test.Foo where foo.string='fizard'"  OK
"from foo in class org.hibernate.test.Foo where foo.component.subcomponent.name='bar'"  OK
"select foo.foo from foo in class org.hibernate.test.Foo where foo.foo.id=?"  OK
"from foo in class org.hibernate.test.Foo where foo.foo = ?"  OK
"from bar in class org.hibernate.test.Bar where bar.string='a string' or bar.string='a string'"  OK
"select foo.component.name, elements(foo.component.importantDates) from foo in class org.hibernate.test.Foo where foo.foo.id=?"  OK
"select max(elements(foo.component.importantDates)) from foo in class org.hibernate.test.Foo group by foo.id"  OK
"select foo.foo.foo.foo from foo in class org.hibernate.test.Foo, foo2 in class org.hibernate.test.Foo where foo = foo2.foo and not not ( not foo.string='fizard' ) and foo2.string between 'a' and (foo.foo.string) and ( foo2.string in ( 'fiz', 'blah') or 1=1 )"  OK
"from foo in class org.hibernate.test.Foo where foo.string='from BoogieDown  -tinsel town  =!@#$^&*())'"  OK
"from foo in class org.hibernate.test.Foo where not foo.string='foo''bar'"  OK
"from foo in class org.hibernate.test.Foo where foo.component.glarch.next is null"  OK
"from bar in class org.hibernate.test.Bar where bar.baz.count=667 and bar.baz.count!=123 and not bar.baz.name='1-E-1'"  OK
"from i in class org.hibernate.test.Bar where i.baz.name='Bazza'"  OK
"select count(distinct foo.foo) from foo in class org.hibernate.test.Foo"  OK
"select count(foo.foo.boolean) from foo in class org.hibernate.test.Foo"  OK
"select count(*), foo.int from foo in class org.hibernate.test.Foo group by foo.int"  OK
"select sum(foo.foo.int) from foo in class org.hibernate.test.Foo"  OK
"select count(foo) from foo in class org.hibernate.test.Foo where foo.id=?"  OK
"from foo in class org.hibernate.test.Foo where foo.boolean = ?"  OK
"select new Foo(fo.x) from org.hibernate.test.Fo fo"  OK
"select new Foo(fo.integer) from org.hibernate.test.Foo fo"  OK
"select new Foo(fo.x) from org.hibernate.test.Foo fo"  OK
"select foo.long, foo.component.name, foo, foo.foo from foo in class org.hibernate.test.Foo"  OK
"select avg(foo.float), max(foo.component.name), count(distinct foo.id) from foo in class org.hibernate.test.Foo"  OK
"select foo.long, foo.component, foo, foo.foo from foo in class org.hibernate.test.Foo"  OK
"from o in class org.hibernate.test.MoreStuff"  OK
"from o in class org.hibernate.test.Many"  OK
"from o in class org.hibernate.test.Fee"  OK
"from o in class org.hibernate.test.Qux"  OK
"from o in class org.hibernate.test.Y"  OK
"from o in class org.hibernate.test.Fumm"  OK
"from o in class org.hibernate.test.X"  OK
"from o in class org.hibernate.test.Simple"  OK
"from o in class org.hibernate.test.Location"  OK
"from o in class org.hibernate.test.Holder"  OK
"from o in class org.hibernate.test.Part"  OK
"from o in class org.hibernate.test.Baz"  OK
"from o in class org.hibernate.test.Vetoer"  OK
"from o in class org.hibernate.test.Sortable"  OK
"from o in class org.hibernate.test.Contained"  OK
"from o in class org.hibernate.test.Stuff"  OK
"from o in class org.hibernate.test.Immutable"  OK
"from o in class org.hibernate.test.Container"  OK
"from o in class org.hibernate.test.X$XX"  OK
"from o in class org.hibernate.test.One"  OK
"from o in class org.hibernate.test.Foo"  OK
"from o in class org.hibernate.test.Fo"  OK
"from o in class org.hibernate.test.Glarch"  OK
"from o in class org.hibernate.test.Fum"  OK
"from n in class org.hibernate.test.Holder"  OK
"from n in class org.hibernate.test.Baz"  OK
"from n in class org.hibernate.test.Bar"  OK
"from n in class org.hibernate.test.Glarch"  OK
"from n in class org.hibernate.test.Holder where n.name is not null"  OK
"from n in class org.hibernate.test.Baz where n.name is not null"  OK
"from n in class org.hibernate.test.Bar where n.name is not null"  OK
"from n in class org.hibernate.test.Glarch where n.name is not null"  OK
"from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Holder where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Holder where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Holder where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Holder where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Baz where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Baz where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Baz where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Baz where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Bar where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Bar where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Bar where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Bar where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Glarch where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Glarch where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Glarch where n0.name = n1.name"  OK
"from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Glarch where n0.name = n1.name"  OK
"from n in class org.hibernate.test.Holder where n.name = :name"  OK
"select baz.code, min(baz.count) from baz in class org.hibernate.test.Baz group by baz.code"  OK
"selecT baz from baz in class org.hibernate.test.Baz where baz.stringDateMap['foo'] is not null or baz.stringDateMap['bar'] = ?"  OK
"select baz from baz in class org.hibernate.test.Baz where baz.stringDateMap['now'] is not null"  OK
"select baz from baz in class org.hibernate.test.Baz where baz.stringDateMap['now'] is not null and baz.stringDateMap['big bang'] < baz.stringDateMap['now']"  OK
"select index(date) from org.hibernate.test.Baz baz join baz.stringDateMap as date"  OK
"select index(date) from org.hibernate.test.Baz baz join baz.stringDateMap date"  OK
"from foo in class org.hibernate.test.Foo where foo.integer not between 1 and 5 and foo.string not in ('cde', 'abc') and foo.string is not null and foo.integer<=3"  OK
"from org.hibernate.test.Baz baz inner join baz.collectionComponent.nested.foos foo where foo.string is null"  OK
"from org.hibernate.test.Baz baz inner join baz.fooSet where '1' in (from baz.fooSet foo where foo.string is not null)"  OK
"from org.hibernate.test.Baz baz where 'a' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)"  OK
"from org.hibernate.test.Foo foo join foo.foo where foo.foo in ('1','2','3')"  OK
"select foo.foo from org.hibernate.test.Foo foo where foo.foo in ('1','2','3')"  OK
"select foo.foo.string from org.hibernate.test.Foo foo where foo.foo in ('1','2','3')"  OK
"select foo.foo.string from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3')"  OK
"select foo.foo.long from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3')"  OK
"select count(*) from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3') or foo.foo.long in (1,2,3)"  OK
"select count(*) from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3') group by foo.foo.long"  OK
"from org.hibernate.test.Foo foo1 left join foo1.foo foo2 left join foo2.foo where foo1.string is not null"  OK
"from org.hibernate.test.Foo foo1 left join foo1.foo.foo where foo1.string is not null"  OK
"from org.hibernate.test.Foo foo1 left join foo1.foo foo2 left join foo1.foo.foo foo3 where foo1.string is not null"  OK
"select foo.formula from org.hibernate.test.Foo foo where foo.formula > 0"  OK
"from org.hibernate.test.Foo as foo join foo.foo as foo2 where foo2.id >'a' or foo2.id <'a'"  OK
"from org.hibernate.test.Holder"  OK
"from org.hibernate.test.Baz baz left outer join fetch baz.manyToAny"  OK
"from org.hibernate.test.Baz baz join baz.manyToAny"  OK
"select baz from org.hibernate.test.Baz baz join baz.manyToAny a where index(a) = 0"  OK
"select bar from org.hibernate.test.Bar bar where bar.baz.stringDateMap['now'] is not null"  OK
"select bar from org.hibernate.test.Bar bar join bar.baaz b where b.stringDateMap['big bang'] < b.stringDateMap['now'] and b.stringDateMap['now'] is not null"  OK
"select bar from org.hibernate.test.Bar bar where bar.baz.stringDateMap['big bang'] < bar.baz.stringDateMap['now'] and bar.baz.stringDateMap['now'] is not null"  OK
"select foo.string, foo.component, foo.id from org.hibernate.test.Bar foo"  OK
"select elements(baz.components) from org.hibernate.test.Baz baz"  OK
"select bc.name from org.hibernate.test.Baz baz join baz.components bc"  OK
"from org.hibernate.test.Foo foo where foo.integer < 10 order by foo.string"  OK
"from org.hibernate.test.Fee"  OK
"from org.hibernate.test.Holder h join h.otherHolder oh where h.otherHolder.name = 'bar'"  OK
"from org.hibernate.test.Baz baz join baz.fooSet foo join foo.foo.foo foo2 where foo2.string = 'foo'"  OK
"from org.hibernate.test.Baz baz join baz.fooArray foo join foo.foo.foo foo2 where foo2.string = 'foo'"  OK
"from org.hibernate.test.Baz baz join baz.stringDateMap date where index(date) = 'foo'"  OK
"from org.hibernate.test.Baz baz join baz.topGlarchez g where index(g) = 'A'"  OK
"select index(g) from org.hibernate.test.Baz baz join baz.topGlarchez g"  OK
"from org.hibernate.test.Baz baz left join baz.stringSet"  OK
"from org.hibernate.test.Baz baz join baz.stringSet str where str='foo'"  OK
"from org.hibernate.test.Baz baz left join fetch baz.stringSet"  OK
"from org.hibernate.test.Baz baz join baz.stringSet string where string='foo'"  OK
"from org.hibernate.test.Baz baz inner join baz.components comp where comp.name='foo'"  OK
"from org.hibernate.test.Glarch g inner join g.fooComponents comp where comp.fee is not null"  OK
"from org.hibernate.test.Glarch g inner join g.fooComponents comp join comp.fee fee where fee.count > 0"  OK
"from org.hibernate.test.Glarch g inner join g.fooComponents comp where comp.fee.count is not null"  OK
"from org.hibernate.test.Baz baz left join fetch baz.fooBag"  OK
"from org.hibernate.test.Glarch"  OK
"from org.hibernate.test.Baz baz left join fetch baz.sortablez order by baz.name asc"  OK
"from org.hibernate.test.Baz baz order by baz.name asc"  OK
"from org.hibernate.test.Foo foo, org.hibernate.test.Baz baz left join fetch baz.fees"  OK
"from org.hibernate.test.Foo foo, org.hibernate.test.Bar bar"  OK
"from org.hibernate.test.Foo foo"  OK
"from org.hibernate.test.Foo foo, org.hibernate.test.Bar bar, org.hibernate.test.Bar bar2"  OK
"from org.hibernate.test.X x"  OK
"select distinct foo from org.hibernate.test.Foo foo"  OK
"from org.hibernate.test.Glarch g where g.multiple.glarch=g and g.multiple.count=12"  OK
"from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar %'"  OK
"select bar, b from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar%'"  OK
"select bar, b from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where ( bar.name in (:nameList0_, :nameList1_, :nameList2_) or bar.name in (:nameList0_, :nameList1_, :nameList2_) ) and bar.string = :stringVal"  OK
"select bar, b from org.hibernate.test.Bar bar inner join bar.baz baz inner join baz.cascadingBars b where bar.name like 'Bar%'"  OK
"select bar, b from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like :name and b.name like :name"  OK
"select bar from org.hibernate.test.Bar as bar where bar.x > ? or bar.short = 1 or bar.string = 'ff ? bb'"  OK
"select bar from org.hibernate.test.Bar as bar where bar.string = ' ? ' or bar.string = '?'"  OK
"from org.hibernate.test.Baz baz, baz.fooArray foo"  OK
"from s in class org.hibernate.test.Stuff where s.foo.id = ? and s.id.id = ? and s.moreStuff.id.intId = ? and s.moreStuff.id.stringId = ?"  OK
"from s in class org.hibernate.test.Stuff where s.foo.id = ? and s.id.id = ? and s.moreStuff.name = ?"  OK
"from s in class org.hibernate.test.Stuff where s.foo.string is not null"  OK
"from s in class org.hibernate.test.Stuff where s.foo > '0' order by s.foo"  OK
"from ms in class org.hibernate.test.MoreStuff"  OK
"from fee in class org.hibernate.test.Fee"  OK
"select new Result(foo.string, foo.long, foo.integer) from foo in class org.hibernate.test.Foo"  OK
"select new Result( baz.name, foo.long, count(elements(baz.fooArray)) ) from org.hibernate.test.Baz baz join baz.fooArray foo group by baz.name, foo.long"  OK
"select new Result( baz.name, max(foo.long), count(foo) ) from org.hibernate.test.Baz baz join baz.fooArray foo group by baz.name"  OK
"select max( elements(bar.baz.fooArray) ) from org.hibernate.test.Bar as bar"  OK
"from org.hibernate.test.Baz baz left join baz.fooToGlarch join fetch baz.fooArray foo left join fetch foo.foo"  OK
"select baz.name from org.hibernate.test.Bar bar inner join bar.baz baz inner join baz.fooSet foo where baz.name = bar.string"  OK
"SELECT baz.name FROM org.hibernate.test.Bar AS bar INNER JOIN bar.baz AS baz INNER JOIN baz.fooSet AS foo WHERE baz.name = bar.string"  OK
"select baz.name from org.hibernate.test.Bar bar join bar.baz baz left outer join baz.fooSet foo where baz.name = bar.string"  OK
"select baz.name from org.hibernate.test.Bar bar, bar.baz baz, baz.fooSet foo where baz.name = bar.string"  OK
"SELECT baz.name FROM org.hibernate.test.Bar AS bar, bar.baz AS baz, baz.fooSet AS foo WHERE baz.name = bar.string"  OK
"select baz.name from org.hibernate.test.Bar bar left join bar.baz baz left join baz.fooSet foo where baz.name = bar.string"  OK
"select foo.string from org.hibernate.test.Bar bar left join bar.baz.fooSet foo where bar.string = foo.string"  OK
"select baz.name from org.hibernate.test.Bar bar left join bar.baz baz left join baz.fooArray foo where baz.name = bar.string"  OK
"select foo.string from org.hibernate.test.Bar bar left join bar.baz.fooArray foo where bar.string = foo.string"  OK
"select foo from bar in class org.hibernate.test.Bar inner join bar.baz as baz inner join baz.fooSet as foo"  OK
"select foo from bar in class org.hibernate.test.Bar inner join bar.baz.fooSet as foo"  OK
"select foo from bar in class org.hibernate.test.Bar, bar.baz as baz, baz.fooSet as foo"  OK
"select foo from bar in class org.hibernate.test.Bar, bar.baz.fooSet as foo"  OK
"from org.hibernate.test.Bar bar join bar.baz.fooArray foo"  OK
"from bar in class org.hibernate.test.Bar, foo in elements( bar.baz.fooArray )"  OK
"select one.id, elements(one.manies) from one in class org.hibernate.test.One"  OK
"select max( elements(one.manies) ) from one in class org.hibernate.test.One"  OK
"select one, elements(one.manies) from one in class org.hibernate.test.One"  OK
"select one, max(elements(one.manies)) from one in class org.hibernate.test.One group by one"  OK
"select elements(baz.fooArray) from baz in class org.hibernate.test.Baz where baz.id=?"  OK
"select indices(baz.fooArray) from baz in class org.hibernate.test.Baz where baz.id=?"  OK
"select baz, max(elements(baz.timeArray)) from baz in class org.hibernate.test.Baz group by baz"  OK
"select baz, baz.stringSet.size, count(distinct elements(baz.stringSet)), max(elements(baz.stringSet)) from baz in class org.hibernate.test.Baz group by baz"  OK
"select max( elements(baz.timeArray) ) from baz in class org.hibernate.test.Baz where baz.id=?"  OK
"select max(elements(baz.stringSet)) from baz in class org.hibernate.test.Baz where baz.id=?"  OK
"select size(baz.stringSet) from baz in class org.hibernate.test.Baz where baz.id=?"  OK
"from org.hibernate.test.Foo foo where foo.component.glarch.id is not null"  OK
"from baz in class org.hibernate.test.Baz"  OK
"select elements(baz.stringArray) from baz in class org.hibernate.test.Baz"  OK
"select elements(baz.stringList) from baz in class org.hibernate.test.Baz"  OK
"select count(*) from org.hibernate.test.Bar"  OK
"select count(*) from b in class org.hibernate.test.Bar"  OK
"from g in class org.hibernate.test.Glarch"  OK
"select baz, baz from baz in class org.hibernate.test.Baz"  OK
"select baz from baz in class org.hibernate.test.Baz order by baz"  OK
"from bar in class org.hibernate.test.Bar"  OK
"from f in class org.hibernate.test.Foo"  OK
"from q in class org.hibernate.test.Qux"  OK
"select foo from foo in class org.hibernate.test.Foo where foo.string='foo bar'"  OK
"from foo in class org.hibernate.test.Foo order by foo.string, foo.date"  OK
"from foo in class org.hibernate.test.Foo where foo.class='B'"  OK
"from foo in class org.hibernate.test.Foo where foo.class=Bar"  OK
"select bar from bar in class org.hibernate.test.Bar, foo in class org.hibernate.test.Foo where bar.string = foo.string and not bar=foo"  OK
"from foo in class org.hibernate.test.Foo where foo.string='foo bar'"  OK
"select foo from foo in class org.hibernate.test.Foo"  OK
"from bar in class org.hibernate.test.Bar where bar.barString='bar bar'"  OK
"from t in class org.hibernate.test.Trivial"  OK
"from foo in class org.hibernate.test.Foo where foo.date = ?"  OK
"from q in class org.hibernate.test.Qux where q.stuff is null"  OK
"from q in class org.hibernate.test.Qux where q.stuff=?"  OK
"from g in class org.hibernate.test.Glarch where g.version=2"  OK
"from g in class org.hibernate.test.Glarch where g.next is not null"  OK
"from g in class org.hibernate.test.Glarch order by g.order asc"  OK
"from foo in class org.hibernate.test.Foo order by foo.string asc"  OK
"select parent, child from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child"  OK
"select count(distinct child.id), count(distinct parent.id) from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child"  OK
"select child.id, parent.id, child.long from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child"  OK
"select child.id, parent.id, child.long, child, parent.foo from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child"  OK
"select parent, child from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child and parent.string='a string'"  OK
"from org.hibernate.test.Foo foo where foo.custom.s1 = 'one'"  OK
"from im in class org.hibernate.test.Immutable where im = ?"  OK
"from foo in class org.hibernate.test.Foo where foo.char='X'"  OK
"select distinct elements(baz.stringArray) from baz in class org.hibernate.test.Baz"  OK
"select elements(baz.fooArray) from baz in class org.hibernate.test.Baz"  OK
"from foo in class org.hibernate.test.Fo"  OK
"from foo in class org.hibernate.test.Foo where foo.dependent.qux.foo.string = 'foo2'"  OK
"from org.hibernate.test.Bar bar where bar.object.id = ? and bar.object.class = ?"  OK
"select one from org.hibernate.test.One one, org.hibernate.test.Bar bar where bar.object.id = one.id and bar.object.class = 'O'"  OK
"from l in class org.hibernate.test.Location where l.countryCode = 'AU' and l.description='foo bar'"  OK
"from org.hibernate.test.Bar bar"  OK
"From org.hibernate.test.Bar bar"  OK
"From org.hibernate.test.Foo foo"  OK
"select fum.id from fum in class org.hibernate.test.Fum where not fum.fum='FRIEND'"  OK
"from fum in class org.hibernate.test.Fum where not fum.fum='FRIEND'"  OK
"from fo in class org.hibernate.test.Fo where fo.id.string like 'an instance of fo'"  OK
"from org.hibernate.test.Outer o where o.id.detailId = ?"  OK
"from org.hibernate.test.Outer o where o.id.master.id.sup.dudu is not null"  OK
"from org.hibernate.test.Outer o where o.id.master.id.sup.id.akey is not null"  OK
"select o.id.master.id.sup.dudu from org.hibernate.test.Outer o where o.id.master.id.sup.dudu is not null"  OK
"select o.id.master.id.sup.id.akey from org.hibernate.test.Outer o where o.id.master.id.sup.id.akey is not null"  OK
"from org.hibernate.test.Outer o where o.id.master.bla = ''"  OK
"from org.hibernate.test.Outer o where o.id.master.id.one = ''"  OK
"from org.hibernate.test.Inner inn where inn.id.bkey is not null and inn.backOut.id.master.id.sup.id.akey > 'a'"  OK
"from org.hibernate.test.Outer as o left join o.id.master m left join m.id.sup where o.bubu is not null"  OK
"from org.hibernate.test.Outer as o left join o.id.master.id.sup s where o.bubu is not null"  OK
"from org.hibernate.test.Outer as o left join o.id.master m left join o.id.master.id.sup s where o.bubu is not null"  OK
"select fum1.fo from fum1 in class org.hibernate.test.Fum where fum1.fo.fum is not null"  OK
"from fum1 in class org.hibernate.test.Fum where fum1.fo.fum is not null order by fum1.fo.fum"  OK
"select elements(fum1.friends) from fum1 in class org.hibernate.test.Fum"  OK
"from fum1 in class org.hibernate.test.Fum, fr in elements( fum1.friends )"  OK
"select new Jay(eye) from org.hibernate.test.Eye eye"  OK
"from org.hibernate.test.Category cat where cat.name='new foo'"  OK
"from org.hibernate.test.Category cat where cat.name='new sub'"  OK
"from org.hibernate.test.Up up order by up.id2 asc"  OK
"from org.hibernate.test.Down down"  OK
"from org.hibernate.test.Up up"  OK
"from m in class org.hibernate.test.Master"  OK
"from s in class org.hibernate.test.Several"  OK
"from s in class org.hibernate.test.Single"  OK
"from d in class org.hibernate.test.Detail"  OK
"from c in class org.hibernate.test.Category where c.name = org.hibernate.test.Category.ROOT_CATEGORY"  OK
"select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where c.oneToMany[2] = s"  OK
"select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where c.manyToMany[2] = s"  OK
"select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where s = c.oneToMany[2]"  OK
"select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where s = c.manyToMany[2]"  OK
"select c from c in class org.hibernate.test.Container where c.oneToMany[0].name = 's'"  OK
"select c from c in class org.hibernate.test.Container where c.manyToMany[0].name = 's'"  OK
"select c from c in class org.hibernate.test.Container where 's' = c.oneToMany[2 - 2].name"  OK
"select c from c in class org.hibernate.test.Container where 's' = c.manyToMany[(3+1)/4-1].name"  OK
"select c from c in class org.hibernate.test.Container where c.manyToMany[ maxindex(c.manyToMany) ].count = 2"  OK
"select c from c in class org.hibernate.test.Container where c.oneToMany[ c.manyToMany[0].count ].name = 's'"  OK
"select c from org.hibernate.test.Container c where c.manyToMany[ c.oneToMany[0].count ].name = 's'"  OK
"select count(comp.name) from org.hibernate.test.Container c join c.components comp"  OK
"from org.hibernate.test.Parent p left join fetch p.child"  OK
"from org.hibernate.test.Parent p join p.child c where c.x > 0"  OK
"from org.hibernate.test.Child c join c.parent p where p.x > 0"  OK
"from org.hibernate.test.Child"  OK
"from org.hibernate.test.MoreStuff"  OK
"from org.hibernate.test.Many"  OK
"from org.hibernate.test.Qux"  OK
"from org.hibernate.test.Fumm"  OK
"from org.hibernate.test.Parent"  OK
"from org.hibernate.test.Simple"  OK
"from org.hibernate.test.Part"  OK
"from org.hibernate.test.Baz"  OK
"from org.hibernate.test.Vetoer"  OK
"from org.hibernate.test.Sortable"  OK
"from org.hibernate.test.Contained"  OK
"from org.hibernate.test.Circular"  OK
"from org.hibernate.test.Stuff"  OK
"from org.hibernate.test.Immutable"  OK
"from org.hibernate.test.Container"  OK
"from org.hibernate.test.One"  OK
"from org.hibernate.test.Fo"  OK
"from org.hibernate.test.Glarch"  OK
"from org.hibernate.test.Fum"  OK
"from org.hibernate.test.Glarch g"  OK
"from org.hibernate.test.Baz baz join baz.parts"  OK
"from c in class org.hibernate.test.Child where c.parent.count=66"  OK
"from org.hibernate.test.Parent p join p.child c where p.count=66"  OK
"select c, c.parent from c in class org.hibernate.test.Child order by c.parent.count"  OK
"select c, c.parent from c in class org.hibernate.test.Child where c.parent.count=66 order by c.parent.count"  OK
"select c, c.parent, c.parent.count from c in class org.hibernate.test.Child order by c.parent.count"  OK
"FROM p IN class org.hibernate.test.Parent WHERE p.count = ?"  OK
"select count(*) from org.hibernate.test.Container as c join c.components as ce join ce.simple as s where ce.name='foo'"  OK
"select c, s from org.hibernate.test.Container as c join c.components as ce join ce.simple as s where ce.name='foo'"  OK
"from s in class org.hibernate.test.Simple"  OK
"from m in class org.hibernate.test.Many"  OK
"from c in class org.hibernate.test.Container"  OK
"from o in class org.hibernate.test.Child"  OK
"from o in class org.hibernate.test.Parent"  OK
"from o in class org.hibernate.test.Circular"  OK
"from c in class org.hibernate.test.C2 where 1=1 or 1=1"  OK
"from b in class org.hibernate.test.B"  OK
"from a in class org.hibernate.test.A"  OK
"from org.hibernate.test.E e join e.reverse as b where b.count=1"  OK
"from org.hibernate.test.E e join e.as as b where b.count=1"  OK
"from org.hibernate.test.B"  OK
"from org.hibernate.test.C1"  OK
"from org.hibernate.test.C2"  OK
"from org.hibernate.test.E e, org.hibernate.test.A a where e.reverse = a.forward and a = ?"  OK
"from org.hibernate.test.E e join fetch e.reverse"  OK
"from org.hibernate.test.E e"  OK
"select max(s.count) from s in class org.hibernate.test.Simple"  OK
"select new org.hibernate.test.S(s.count, s.address) from s in class org.hibernate.test.Simple"  OK
"select count(*) from s in class org.hibernate.test.Simple"  OK
"from s in class org.hibernate.test.Simple where s.name=:name and s.count=:count"  OK
"from s in class org.hibernate.test.Simple where s.name in (:several0_, :several1_)"  OK
"from s in class org.hibernate.test.Simple where s.name in (:stuff0_, :stuff1_)"  OK
"from org.hibernate.test.Simple s where s.name=?"  OK
"from org.hibernate.test.Simple s where s.name=:name"  OK
"from s in class org.hibernate.test.Simple where upper( s.name ) ='SIMPLE 1'"  OK
"from s in class org.hibernate.test.Simple where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"  OK
"from s in class org.hibernate.test.Simple where lower( s.name || ' foo' ) ='simple 1 foo'"  OK
"from s in class org.hibernate.test.Simple where upper( s.other.name ) ='SIMPLE 2'"  OK
"from s in class org.hibernate.test.Simple where not ( upper( s.other.name ) ='SIMPLE 2' )"  OK
"select distinct s from s in class org.hibernate.test.Simple where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2"  OK
"select s from s in class org.hibernate.test.Simple where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count"  OK
"select sum(s.count) from s in class org.hibernate.test.Simple group by s.count having sum(s.count) > 10"  OK
"select s.count from s in class org.hibernate.test.Simple group by s.count having s.count = 12"  OK
"select s.id, s.count, count(t), max(t.date) from s in class org.hibernate.test.Simple, t in class org.hibernate.test.Simple where s.count = t.count group by s.id, s.count order by s.count"  OK
"from s in class org.hibernate.test.Simple where s.name = ?"  OK
"from s in class org.hibernate.test.Simple where s.name = ? and upper(s.name) = ?"  OK
"from s in class org.hibernate.test.Simple where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1"  OK
"select s.id from s in class org.hibernate.test.Simple"  OK
"select all s, s.other from s in class org.hibernate.test.Simple where s = :s"  OK
"from s in class org.hibernate.test.Simple where s.name in (:name_list0_, :name_list1_) and s.count > :count"  OK
"from org.hibernate.test.Simple s"  OK
"from org.hibernate.test.Assignable"  OK
"from org.hibernate.test.Category"  OK
"from org.hibernate.test.A"  OK
"from foo in class org.hibernate.test.Foo where foo.string=?"  OK
"from foo in class org.hibernate.test.Foo"  OK
"from org.hibernate.test.Po po, org.hibernate.test.Lower low where low.mypo = po"  OK
"from org.hibernate.test.Po po join po.set as sm where sm.amount > 0"  OK
"from org.hibernate.test.Po po join po.top as low where low.foo = 'po'"  OK
"from org.hibernate.test.SubMulti sm join sm.children smc where smc.name > 'a'"  OK
"select s, ya from org.hibernate.test.Lower s join s.yetanother ya"  OK
"from org.hibernate.test.Lower s1 join s1.bag s2"  OK
"from org.hibernate.test.Lower s1 left join s1.bag s2"  OK
"select s, a from org.hibernate.test.Lower s join s.another a"  OK
"select s, a from org.hibernate.test.Lower s left join s.another a"  OK
"from org.hibernate.test.Top s, org.hibernate.test.Lower ls"  OK
"from org.hibernate.test.Lower ls join ls.set s where s.name > 'a'"  OK
"from org.hibernate.test.Po po join po.list sm where sm.name > 'a'"  OK
"from org.hibernate.test.Lower ls inner join ls.another s where s.name is not null"  OK
"from org.hibernate.test.Lower ls where ls.other.another.name is not null"  OK
"from org.hibernate.test.Multi m where m.derived like 'F%'"  OK
"from org.hibernate.test.SubMulti m where m.derived like 'F%'"  OK
"select s from org.hibernate.test.SubMulti as sm join sm.children as s where s.amount>-1 and s.name is null"  OK
"select elements(sm.children) from org.hibernate.test.SubMulti as sm"  OK
"select distinct sm from org.hibernate.test.SubMulti as sm join sm.children as s where s.amount>-1 and s.name is null"  OK
"select distinct s from s in class org.hibernate.test.SubMulti where s.moreChildren[1].amount < 1.0"  OK
"from s in class org.hibernate.test.TrivialClass where s.id = 2"  OK
"select s.count from s in class org.hibernate.test.Top"  OK
"from s in class org.hibernate.test.Lower where s.another.name='name'"  OK
"from s in class org.hibernate.test.Lower where s.yetanother.name='name'"  OK
"from s in class org.hibernate.test.Lower where s.yetanother.name='name' and s.yetanother.foo is null"  OK
"from s in class org.hibernate.test.Top where s.count=1"  OK
"select s.count from s in class org.hibernate.test.Top, ls in class org.hibernate.test.Lower where ls.another=s"  OK
"select elements(ls.bag), elements(ls.set) from ls in class org.hibernate.test.Lower"  OK
"from s in class org.hibernate.test.Lower"  OK
"from s in class org.hibernate.test.Top"  OK
"from sm in class org.hibernate.test.SubMulti"  OK
"select s from s in class org.hibernate.test.Top where s.count>0"  OK
"from m in class org.hibernate.test.Multi where m.count>0 and m.extraProp is not null"  OK
"from m in class org.hibernate.test.Top where m.count>0 and m.name is not null"  OK
"from m in class org.hibernate.test.Lower where m.other is not null"  OK
"from m in class org.hibernate.test.Multi where m.other.id = 1"  OK
"from m in class org.hibernate.test.SubMulti where m.amount > 0.0"  OK
"from m in class org.hibernate.test.Multi"  OK
"from m in class org.hibernate.test.Multi where m.class = SubMulti"  OK
"from m in class org.hibernate.test.Top where m.class = Multi"  OK
"from ls in class org.hibernate.test.Lower"  OK
"from ls in class org.hibernate.test.Lower, s in elements(ls.bag) where s.id is not null"  OK
"from ls in class org.hibernate.test.Lower, s in elements(ls.set) where s.id is not null"  OK
"from o in class org.hibernate.test.Top"  OK
"from o in class org.hibernate.test.Po"  OK
"from ChildMap cm where cm.parent is not null"  OK
"from ParentMap cm where cm.child is not null"  OK
"from org.hibernate.test.Componentizable"  OK
[testUnnamedParameter]
"select foo, bar from org.hibernate.test.Foo foo left outer join foo.foo bar where foo = ?"  OK
[testInElements]
"from bar in class org.hibernate.test.Bar, foo in elements(bar.baz.fooArray)"  OK
"from org.hibernate.test.Bar bar, foo in elements(bar.baz.fooArray)"  OK
[testDotElements]
"select distinct foo from baz in class org.hibernate.test.Baz, foo in elements(baz.fooArray)"  OK
"select foo from baz in class org.hibernate.test.Baz, foo in elements(baz.fooSet)"  OK
"select foo from baz in class org.hibernate.test.Baz, foo in elements(baz.fooArray)"  OK
"from org.hibernate.test.Baz baz where 'b' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)"  OK
[testNot]
"from eg.Cat cat where not ( cat.kittens.size < 1 )"  OK
"from eg.Cat cat where not ( cat.kittens.size > 1 )"  OK
"from eg.Cat cat where not ( cat.kittens.size >= 1 )"  OK
"from eg.Cat cat where not ( cat.kittens.size <= 1 )"  OK
"from eg.DomesticCat cat where not ( cat.name between 'A' and 'B' )"  OK
"from eg.DomesticCat cat where not ( cat.name not between 'A' and 'B' )"  OK
"from eg.Cat cat where not ( not cat.kittens.size <= 1 )"  OK
"from eg.Cat cat where not  not ( not cat.kittens.size <= 1 )"  OK
[testOtherSyntax]
"select bar from org.hibernate.test.Bar bar order by ((bar.x - :valueX)*(bar.x - :valueX))"  OK
"from bar in class org.hibernate.test.Bar, foo in elements(bar.baz.fooSet)"  OK
"from one in class org.hibernate.test.One, many in elements(one.manies) where one.id = 1 and many.id = 1"  OK
"from org.hibernate.test.Inner _inner join _inner.middles middle"  OK
// HQLPARSER-41 "FROM m IN class org.hibernate.test.Master WHERE NOT EXISTS ( FROM d IN elements(m.details) WHERE NOT d.i=5 )"  OK
// HQLPARSER-41 "FROM m IN class org.hibernate.test.Master WHERE NOT 5 IN ( SELECT d.i FROM d IN elements(m.details) )"  OK
"SELECT m FROM m IN class org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"  OK
"SELECT m.id FROM m IN class org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5"  OK
//I'm not sure about these... [jsd]
//"select bar.string, foo.string from bar in class org.hibernate.test.Bar inner join bar.baz as baz inner join elements(baz.fooSet) as foo where baz.name = 'name'"  OK
//"select bar.string, foo.string from bar in class org.hibernate.test.Bar, bar.baz as baz, elements(baz.fooSet) as foo where baz.name = 'name'"  OK
//"select count(*) where this.amount>-1 and this.name is null"  OK
//"from sm in class org.hibernate.test.SubMulti where exists sm.children.elements"  OK
[testEjbqlExtensions]
"select object(a) from Animal a where a.mother member of a.offspring"  OK
"select object(a) from Animal a where a.offspring is empty"  OK
[testHB1042]
"select x from fmc_web.pool.Pool x left join x.containers c0 where (upper(x.name) = upper(':') and c0.id = 1)"  OK
[testKeywordInPath]
"from Customer c where c.order.status = 'argh'"  OK
"from Customer c where c.order.count > 3"  OK
"select c.where from Customer c where c.order.count > 3"  OK
"from Interval i where i.end <:end"  OK
"from Letter l where l.case = :case"  OK
[testPathologicalKeywordAsIdentifier]
"from Order order"  OK
"from Order order join order.group"  OK
"from X x order by x.group.by.from"  OK
"from Order x order by x.order.group.by.from"  OK
"select order.id from Order order"  OK
"select order from Order order"  OK
"from Order order where order.group.by.from is not null"  OK
"from Order order order by order.group.by.from"  OK
"from Group as group group by group.by.from"  OK
[testHHH354]
"from Foo f where f.full = 'yep'"  OK
[testWhereAsIdentifier]
"from where.Order"  OK
[testConstructorIn]
"from org.hibernate.test.Bar bar where (b.x, b.y, b.z) in (select foo, bar, baz from org.hibernate.test.Foo)"  OK
[testMultiByteCharacters]
"from User user where user.name like '%nn\u4e2dnn%'"  OK
//FIXME "from User user where user.\u432d like '%\u4e2d%'"  OK
//FIXME "from \u432d \u432d where \u432d.name like '%fred%'"  OK
[testHHH719]
"from Foo f order by com.fooco.SpecialFunction(f.id)"  OK
[testHHH1107]
"from Animal where zoo.address.street = '123 Bogus St.'"  OK
[testHHH1247]
"select distinct user.party from com.itf.iceclaims.domain.party.user.UserImpl user inner join user.party.$RelatedWorkgroups relatedWorkgroups where relatedWorkgroups.workgroup.id = :workgroup and relatedWorkgroups.effectiveTime.start <= :datesnow and relatedWorkgroups.effectiveTime.end > :dateenow "  OK
[testLineAndColumnNumber]
"from Foo f where f.name = 'fred'"  OK
//
"from Animal a where a.bodyWeight = ?1"  OK
"select object(m) from Model m"  OK
"select o from Animal a inner join a.offspring o"  OK
"select object(o) from Animal a, in(a.offspring) o"  OK
"from Animal a where not exists elements(a.offspring)"  OK
"from Animal a where exists (from a.mother.father.offspring)"  OK
"select object(a) from Animal a where a.mother.father.offspring is not empty"  OK
"from Animal a where a.mother in (from a.offspring)"  OK
"from Animal a where a.mother not in (from a.offspring)"  OK
"select object(a) from Animal a where a.mother not member of a.offspring"  OK
"select object(a) from Animal a where a.description = concat('1', concat('2','3'), '4'||'5')||0"  OK
"from Animal a where substring(a.description, 1, 3) = :p1"  OK
"select substring(a.description, 1, 3) from Animal a"  OK
"from Animal a where lower(a.description) = :p1"  OK
"from Animal a where upper(a.description) = :p1"  OK
"from Animal a where length(a.description) = :p1"  OK
"select length(a.description) from Animal a"  OK
"from Animal a where locate(a.description, 'abc', 2) = :p1"  OK
"select locate(a.description, :p1, 2) from Animal a"  OK
"select object(a) from Animal a where trim(trailing '_' from a.description) = :p1"  OK
"select trim(trailing '_' from a.description) from Animal a"  OK
"select object(a) from Animal a where trim(leading '_' from a.description) = :p1"  OK
"select object(a) from Animal a where trim(both a.description) = :p1"  FAIL
"select object(a) from Animal a where trim(a.description) = :p1"  OK
"select object(a) from Animal a where abs(a.bodyWeight) = sqrt(a.bodyWeight)"  OK
"select object(a) from Animal a where mod(a.bodyWeight, a.mother.bodyWeight) = :p1"  OK
"select object(a) from Animal a where BIT_LENGTH(a.bodyWeight) = :p1"  OK
"select BIT_LENGTH(a.bodyWeight) from Animal a"  OK
"select object(a) from Animal a where CURRENT_DATE = :p1 or CURRENT_TIME = :p2 or CURRENT_TIMESTAMP = :p3"  OK
"select object(a) from Animal a where a.bodyWeight like '%a%'"  OK
"select object(a) from Animal a where a.bodyWeight not like '%a%'"  OK
"select object(a) from Animal a where a.bodyWeight like '%a%' escape '%'"  OK
"from Human h where h.pregnant is true"  FAIL
"from Human h where h.pregnant = true"  OK
"from Human h where h.pregnant is false"  FAIL
"from Human h where h.pregnant = false"  OK
"from Human h where not(h.pregnant is true)"  FAIL
"from Human h where not( h.pregnant=true )"  OK
"select CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP from Animal a"  OK
"select p.name, a.zipCode, count(*) from Person p left outer join Employee e on e.id = p.id and p.type = 'E' and (e.effective>? or e.effective<?) join Address a on a.pid = p.id where upper(p.name) like 'G%' and p.age > 100 and (p.sex = 'M' or p.sex = 'F') and coalesce( trim(a.street), a.city, (a.zip) ) is not null order by p.name asc, a.zipCode asc"  OK
"select ( (m.age - p.age) * 12 ), trim(upper(p.name)) from Person p, Person m where p.mother = m.id and ( p.age = (select max(p0.age) from Person p0 where (p0.mother=m.id)) and p.name like ? )"  OK
"select * from Address a join Person p on a.pid = p.id, Person m join Address b on b.pid = m.id where p.mother = m.id and p.name like ?"  FAIL
"select case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end from Person p where ( case when p.age > 50 then 'old' when p.age > 18 then 'adult' else 'child' end ) like ?"  OK
[HQLTest.testInvalidCollectionDereferencesFail]
"from Animal a where a.offspring.description = 'xyz'"  OK
"from Animal a where a.offspring.father.description = 'xyz'"  OK
[HQLTest.testSubComponentReferences]
"select c.address.zip.code from ComponentContainer c"  OK
"select c.address.zip from ComponentContainer c"  OK
"select c.address from ComponentContainer c"  OK
[HQLTest.testManyToAnyReferences]
"from PropertySet p where p.someSpecificProperty.id is not null"  OK
"from PropertySet p join p.generalProperties gp where gp.id is not null"  OK
[HQLTest.testCollectionJoinsInSubselect]
"select a.id, a.description from Animal a left join a.offspring where a in ( select a1 from Animal a1 left join a1.offspring o where a1.id=1)"  OK
"select h.id, h.description from Human h left join h.friends where h in ( select h1 from Human h1 left join h1.friends f where h1.id=1 )"  OK
[HQLTest.testEmptyInListFailureExpected]
"select a from Animal a where a.description in ()"  FAIL
"select o.orderDate - o.orderDate from Order o"  OK
[HQLTest.testDateTimeArithmeticReturnTypesAndParameterGuessing]
"select o.orderDate + 2 from Order o"  OK
"select o.orderDate -2 from Order o"  OK
"from Order o where o.orderDate > ?"  OK
"select o.orderDate + ? from Order o"  OK
[HQLTest.testReturnMetadata]
"select a as animal from Animal a"  OK
"select o as entity from java.lang.Object o"  OK
[HQLTest.testImplicitJoinsAlongWithCartesianProduct]
"select foo.foo from Foo foo, Foo foo2"  OK
"select foo.foo.foo from Foo foo, Foo foo2"  OK
[HQLTest.testSubselectBetween]
"from Animal x where (select max(a.bodyWeight) from Animal a) between :min and :max"  OK
"from Animal x where (select max(a.description) from Animal a) like 'big%'"  OK
"from Animal x where (select max(a.bodyWeight) from Animal a) is not null"  OK
"from Animal x where exists (select max(a.bodyWeight) from Animal a)"  OK
"from Animal x where (select max(a.bodyWeight) from Animal a) in (1,2,3)"  OK
[HQLTest.testFetchOrderBy]
"from Animal a left outer join fetch a.offspring where a.mother.id = :mid order by a.description"  OK
[HQLTest.testCollectionOrderBy]
"from Animal a join a.offspring o order by a.description"  OK
"from Animal a join fetch a.offspring order by a.description"  OK
"from Animal a join fetch a.offspring o order by o.description"  OK
"from Animal a join a.offspring o order by a.description, o.description"  OK
[HQLTest.testExpressionWithParamInFunction]
"from Animal a where abs(a.bodyWeight-:param) < 2.0"  OK
"from Animal a where abs(:param - a.bodyWeight) < 2.0"  OK
[HQLTest.testCompositeKeysWithPropertyNamedId]
"select e.id.id from EntityWithCrazyCompositeKey e"  OK
"select max(e.id.id) from EntityWithCrazyCompositeKey e"  OK
[HQLTest.testMaxindexHqlFunctionInElementAccessorFailureExpected]
"select c from ContainerX c where c.manyToMany[ maxindex(c.manyToMany) ].count = 2"  OK
"select c from Container c where c.manyToMany[ maxIndex(c.manyToMany) ].count = 2"  OK
[HQLTest.testMultipleElementAccessorOperatorsFailureExpected]
"select c from ContainerX c where c.oneToMany[ c.manyToMany[0].count ].name = 's'"  OK
[HQLTest.testKeyManyToOneJoinFailureExpected]
"from Order o left join fetch o.lineItems li left join fetch li.product p"  OK
"from Outer o where o.id.master.id.sup.dudu is not null"  OK
[HQLTest.testDuplicateExplicitJoinFailureExpected]
"from Animal a join a.mother m1 join a.mother m2"  OK
"from Zoo zoo join zoo.animals an join zoo.mammals m"  OK
"from Zoo zoo join zoo.mammals an join zoo.mammals m"  OK
[HQLTest.testIndexWithExplicitJoin]
"from Zoo zoo join zoo.animals an where zoo.mammals[ index(an) ] = an"  OK
"from Zoo zoo join zoo.mammals dog where zoo.mammals[ index(dog) ] = dog"  OK
"from Zoo zoo join zoo.mammals dog where dog = zoo.mammals[ index(dog) ]"  OK
[HQLTest.testOneToManyMapIndex]
"from Zoo zoo where zoo.mammals['dog'].description like '%black%'"  OK
"from Zoo zoo where zoo.mammals['dog'].father.description like '%black%'"  OK
"from Zoo zoo where zoo.mammals['dog'].father.id = 1234"  OK
"from Zoo zoo where zoo.animals['1234'].description like '%black%'"  OK
[HQLTest.testExplicitJoinMapIndex]
"from Zoo zoo, Dog dog where zoo.mammals['dog'] = dog"  OK
"from Zoo zoo join zoo.mammals dog where zoo.mammals['dog'] = dog"  OK
[HQLTest.testIndexFunction]
"from Zoo zoo join zoo.mammals dog where index(dog) = 'dog'"  OK
"from Zoo zoo join zoo.animals an where index(an) = '1234'"  OK
[HQLTest.testSelectCollectionOfValues]
"select baz, date from Baz baz join baz.stringDateMap date where index(date) = 'foo'"  OK
[HQLTest.testCollectionOfValues]
"from Baz baz join baz.stringDateMap date where index(date) = 'foo'"  OK
[HQLTest.testHHH719]
"from Baz b order by org.bazco.SpecialFunction(b.id)"  OK
"from Baz b order by anypackage.anyFunction(b.id)"  OK
[HQLTest.testParameterListExpansion]
"from Animal as animal where animal.id in (:idList_1, :idList_2)"  OK
[HQLTest.testComponentManyToOneDereferenceShortcut]
"from Zoo z where z.address.stateProvince.id is null"  OK
[HQLTest.testNestedCollectionImplicitJoins]
"select h.friends.offspring from Human h"  OK
[HQLTest.testExplicitJoinsInSubquery]
"from org.hibernate.test.hql.Animal as animal where animal.id in ( select a.id from org.hibernate.test.hql.Animal as a left join a.mother as mo )"  OK
[HQLTest.testImplicitJoinsInGroupBy]
"select o.mother.bodyWeight, count(distinct o) from Animal an join an.offspring as o group by o.mother.bodyWeight"  OK
[HQLTest.testCrazyIdFieldNames]
"select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null"  OK
"select e.heresAnotherCrazyIdFieldName.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null"  OK
[HQLTest.testSizeFunctionAndProperty]
"from Animal a where a.offspring.size > 0"  OK
"from Animal a join a.offspring where a.offspring.size > 1"  OK
"from Animal a where size(a.offspring) > 0"  OK
"from Animal a join a.offspring o where size(a.offspring) > 1"  OK
"from Animal a where size(a.offspring) > 1 and size(a.offspring) < 100"  OK
"from Human a where a.family.size > 0"  OK
"from Human a join a.family where a.family.size > 1"  OK
"from Human a where size(a.family) > 0"  OK
"from Human a join a.family o where size(a.family) > 1"  OK
"from Human a where a.family.size > 0 and a.family.size < 100"  OK
[HQLTest.testFromOnly]
"from Animal"  OK
"from Model"  OK
[HQLTest.testJoinPathEndingInValueCollection]
"select h from Human as h join h.nickNames as nn where h.nickName=:nn1 and (nn=:nn2 or nn=:nn3)"  OK
[HQLTest.testSerialJoinPathEndingInValueCollection]
"select h from Human as h join h.friends as f join f.nickNames as nn where h.nickName=:nn1 and (nn=:nn2 or nn=:nn3)"  OK
[HQLTest.testImplicitJoinContainedByCollectionFunction]
"from Human as h where 'shipping' in indices(h.father.addresses)"  OK
"from Human as h where 'shipping' in indices(h.father.father.addresses)"  OK
"from Human as h where 'sparky' in elements(h.father.nickNames)"  OK
"from Human as h where 'sparky' in elements(h.father.father.nickNames)"  OK
[HQLTest.testImpliedJoinInSubselectFrom]
"from Animal a where exists( from a.mother.offspring )"  OK
[HQLTest.testSubselectImplicitJoins]
"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count )"  OK
[HQLTest.testCollectionOfValuesSize]
"select size(baz.stringDateMap) from org.hibernate.test.legacy.Baz baz"  OK
[HQLTest.testCollectionFunctions]
"from Zoo zoo where size(zoo.animals) > 100"  OK
"from Zoo zoo where maxindex(zoo.mammals) = 'dog'"  OK
[HQLTest.testImplicitJoinInExplicitJoin]
"from Animal an inner join an.mother.mother gm"  OK
"from Animal an inner join an.mother.mother.mother ggm"  OK
"from Animal an inner join an.mother.mother.mother.mother gggm"  OK
[HQLTest.testImpliedManyToManyProperty]
"select c from ContainerX c where c.manyToMany[0].name = 's'"  OK
"select size(zoo.animals) from Zoo zoo"  OK
[HQLTest.testCollectionIndexFunctionsInSelect"  OK]
"select maxindex(zoo.animals) from Zoo zoo"  OK
"select minindex(zoo.animals) from Zoo zoo"  OK
"select indices(zoo.animals) from Zoo zoo"  OK
[HQLTest.testCollectionElementFunctionsInSelect]
"select maxelement(zoo.animals) from Zoo zoo"  OK
"select minelement(zoo.animals) from Zoo zoo"  OK
"select elements(zoo.animals) from Zoo zoo"  OK
[HQLTest.testFetchCollectionOfValues]
"from Baz baz left join fetch baz.stringSet"  OK
[HQLTest.testFetchList]
"from User u join fetch u.permissions"  OK
[HQLTest.testCollectionFetchWithExplicitThetaJoin]
"select m from Master m1, Master m left join fetch m.details where m.name=m1.name"  OK
[HQLTest.testListElementFunctionInSelect]
"select maxelement(u.permissions) from User u"  OK
"select elements(u.permissions) from User u"  OK
[HQLTest.testListElementFunctionInWhere]
"from User u where 'read' in elements(u.permissions)"  OK
"from User u where 'write' <> all elements(u.permissions)"  OK
[HQLTest.testManyToManyElementFunctionInSelect]
"select maxelement(human.friends) from Human human"  OK
"select elements(human.friends) from Human human"  OK
[HQLTest.testManyToManyMaxElementFunctionInWhere]
"from Human human where 5 = maxelement(human.friends)"  OK
[HQLTest.testCollectionIndexFunctionsInWhere]
"from Zoo zoo where 4 = maxindex(zoo.animals)"  OK
"from Zoo zoo where 2 = minindex(zoo.animals)"  OK
[HQLTest.testCollectionIndicesInWhere]
"from Zoo zoo where 4 > some indices(zoo.animals)"  OK
"from Zoo zoo where 4 > all indices(zoo.animals)"  OK
[HQLTest.testIndicesInWhere]
"from Zoo zoo where 4 in indices(zoo.animals)"  OK
"from Zoo zoo where exists indices(zoo.animals)"  OK
[HQLTest.testCollectionElementInWhere]
"from Zoo zoo where 4 > some elements(zoo.animals)"  OK
"from Zoo zoo where 4 > all elements(zoo.animals)"  OK
[HQLTest.testElementsInWhere]
"from Zoo zoo where 4 in elements(zoo.animals)"  OK
"from Zoo zoo where exists elements(zoo.animals)"  OK
[HQLTest.testNull]
"from Human h where h.nickName is null"  OK
"from Human h where h.nickName is not null"  OK
[HQLTest.testSubstitutions]
"from Human h where h.pregnant = yes"  OK
"from Human h where h.pregnant = foo"  OK
[HQLTest.testEscapedQuote]
"from Human h where h.nickName='1 ov''tha''few'"  OK
[HQLTest.testCaseWhenElse]
"from Human h where case when h.nickName='1ovthafew' then 'Gavin' when h.nickName='turin' then 'Christian' else h.nickName end = h.name.first"  OK
[HQLTest.testCaseExprWhenElse]
"from Human h where case h.nickName when '1ovthafew' then 'Gavin' when 'turin' then 'Christian' else h.nickName end = h.name.first"  OK
[HQLTest.testInvalidHql]
"from Animal foo where an.bodyWeight > 10"  OK
"select an.name from Animal foo"  OK
"from Animal foo where an.verybogus > 10"  OK
"select an.boguspropertyname from Animal foo"  OK
"select an.name"  FAIL
"from Animal an where (((an.bodyWeight > 10 and an.bodyWeight < 100)) or an.bodyWeight is null"  FAIL
"from Animal an where an.bodyWeight is null where an.bodyWeight is null"  FAIL
["from where name='foo'"  FAIL //This fails only when no entity is named "where" (Improve on?)]
"from NonexistentClass where name='foo'"  OK
"select new FOO_BOGUS_Animal(an.description, an.bodyWeight) from Animal an"  OK
"select new Animal(an.description, an.bodyWeight, 666) from Animal an"  OK
[HQLTest.testWhereBetween]
"from Animal an where an.bodyWeight between 1 and 10"  OK
[HQLTest.testConcatenation]
"from Human h where h.nickName = '1' || 'ov' || 'tha' || 'few'"  OK
[HQLTest.testWhereLike]
"from Animal a where a.description like '%black%'"  OK
"from Animal an where an.description like '%fat%'"  OK
"from Animal an where lower(an.description) like '%fat%'"  OK
[HQLTest.testWhereIn]
"from Animal an where an.description in ('fat', 'skinny')"  OK
[HQLTest.testLiteralInFunction]
"from Animal an where an.bodyWeight > abs(5)"  OK
"from Animal an where an.bodyWeight > abs(-5)"  OK
[HQLTest.testExpressionInFunction]
"from Animal an where an.bodyWeight > abs(3-5)"  OK
"from Animal an where an.bodyWeight > abs(3/5)"  OK
"from Animal an where an.bodyWeight > abs(3+5)"  OK
"from Animal an where an.bodyWeight > abs(3*5)"  OK
[HQLTest.testNotOrWhereClause]
"from Simple s where 'foo'='bar' or not 'foo'='foo'"  OK
"from Simple s where 'foo'='bar' or not ('foo'='foo')"  OK
"from Simple s where not ( 'foo'='bar' or 'foo'='foo' )"  OK
"from Simple s where not ( 'foo'='bar' and 'foo'='foo' )"  OK
"from Simple s where not ( 'foo'='bar' and 'foo'='foo' ) or not ('x'='y')"  OK
"from Simple s where not ( 'foo'='bar' or 'foo'='foo' ) and not ('x'='y')"  OK
"from Simple s where not ( 'foo'='bar' or 'foo'='foo' ) and 'x'='y'"  OK
"from Simple s where not ( 'foo'='bar' and 'foo'='foo' ) or 'x'='y'"  OK
"from Simple s where 'foo'='bar' and 'foo'='foo' or not 'x'='y'"  OK
"from Simple s where 'foo'='bar' or 'foo'='foo' and not 'x'='y'"  OK
"from Simple s where ('foo'='bar' and 'foo'='foo') or 'x'='y'"  OK
"from Simple s where ('foo'='bar' or 'foo'='foo') and 'x'='y'"  OK
"from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"  OK
[HQLTest.testComplexExpressionInFunction]
"from Animal an where an.bodyWeight > abs((3-5)/4)"  OK
[HQLTest.testStandardFunctions]
"from Animal where current_date = current_time"  OK
"from Animal a where upper(a.description) = 'FAT'"  OK
"select lower(a.description) from Animal a"  OK
[HQLTest.testOrderBy]
"from Animal an order by an.bodyWeight"  OK
"from Animal an order by an.bodyWeight asc"  OK
"from Animal an order by an.bodyWeight desc"  OK
"from Animal an order by sqrt(an.bodyWeight*4)/2"  OK
"from Animal an order by an.mother.bodyWeight"  OK
"from Animal an order by an.bodyWeight, an.description"  OK
"from Animal an order by an.bodyWeight asc, an.description desc"  OK
"from Human h order by sqrt(h.bodyWeight), year(h.birthdate)"  OK
[HQLTest.testGroupByFunction]
"select count(*) from Human h group by year(h.birthdate)"  OK
"select count(*) from Human h group by trunc( sqrt(h.bodyWeight*4)/2 )"  OK
"select count(*) from Human h group by year(sysdate)"  OK
[HQLTest.testPolymorphism]
"from Mammal"  OK
"from Dog"  OK
"from Mammal m where m.pregnant = false and m.bodyWeight > 10"  OK
"from Dog d where d.pregnant = false and d.bodyWeight > 10"  OK
[HQLTest.testProduct]
"from Animal, Animal"  OK
"from Animal x, Animal y where x.bodyWeight = y.bodyWeight"  OK
"from Animal x, Mammal y where x.bodyWeight = y.bodyWeight and not y.pregnant = true"  OK
"from Mammal, Mammal"  OK
[HQLTest.testJoinedSubclassProduct]
"from PettingZoo, PettingZoo"  OK
[HQLTest.testProjectProduct]
"select x from Human x, Human y where x.nickName = y.nickName"  OK
"select x, y from Human x, Human y where x.nickName = y.nickName"  OK
[HQLTest.testExplicitEntityJoins]
"from Animal an inner join an.mother mo"  OK
"from Animal an left outer join an.mother mo"  OK
"from Animal an left outer join fetch an.mother"  OK
[HQLTest.testMultipleExplicitEntityJoins]
"from Animal an inner join an.mother mo inner join mo.mother gm"  OK
"from Animal an left outer join an.mother mo left outer join mo.mother gm"  OK
"from Animal an inner join an.mother m inner join an.father f"  OK
"from Animal an left join fetch an.mother m left join fetch an.father f"  OK
[HQLTest.testMultipleExplicitJoins]
"from Animal an inner join an.mother mo inner join an.offspring os"  OK
"from Animal an left outer join an.mother mo left outer join an.offspring os"  OK
[HQLTest.testExplicitEntityJoinsWithRestriction]
"from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight"  OK
[HQLTest.testIdProperty]
"from Animal a where a.mother.id = 12"  OK
[HQLTest.testSubclassAssociation]
"from DomesticAnimal da join da.owner o where o.nickName = 'Gavin'"  OK
"from DomesticAnimal da left join fetch da.owner"  OK
"from Human h join h.pets p where p.pregnant = 1"  OK
"from Human h join h.pets p where p.bodyWeight > 100"  OK
"from Human h left join fetch h.pets"  OK
[HQLTest.testExplicitCollectionJoins]
"from Animal an inner join an.offspring os"  OK
"from Animal an left outer join an.offspring os"  OK
[HQLTest.testExplicitOuterJoinFetch]
"from Animal an left outer join fetch an.offspring"  OK
[HQLTest.testExplicitOuterJoinFetchWithSelect]
"select an from Animal an left outer join fetch an.offspring"  OK
[HQLTest.testExplicitJoins]
"from Zoo zoo join zoo.mammals mam where mam.pregnant = true and mam.description like '%white%'"  OK
"from Zoo zoo join zoo.animals an where an.description like '%white%'"  OK
[HQLTest.testMultibyteCharacterConstant]
"from Zoo zoo join zoo.animals an where an.description like '%\u4e2d%'"  OK
[HQLTest.testImplicitJoins]
"from Animal an where an.mother.bodyWeight > ?"  OK
"from Animal an where an.mother.bodyWeight > 10"  OK
"from Dog dog where dog.mother.bodyWeight > 10"  OK
"from Animal an where an.mother.mother.bodyWeight > 10"  OK
"from Animal an where an.mother is not null"  OK
"from Animal an where an.mother.id = 123"  OK
[HQLTest.testImplicitJoinInSelect]
"select foo, foo.long from Foo foo"  OK
"select foo.foo from Foo foo"  OK
"select foo, foo.foo from Foo foo"  OK
"select foo.foo from Foo foo where foo.foo is not null"  OK
[HQLTest.testSelectExpressions]
"select an.mother.mother from Animal an"  OK
"select an.mother.mother.mother from Animal an"  OK
"select an.mother.mother.bodyWeight from Animal an"  OK
"select an.mother.zoo.id from Animal an"  OK
"select user.human.zoo.id from User user"  OK
"select u.userName, u.human.name.first from User u"  OK
"select u.human.name.last, u.human.name.first from User u"  OK
"select bar.baz.name from Bar bar"  OK
"select bar.baz.name, bar.baz.count from Bar bar"  OK
[HQLTest.testSelectStandardFunctionsNoParens]
"select current_date, current_time, current_timestamp from Animal"  OK
[HQLTest.testMapIndex]
"from User u where u.permissions['hibernate']='read'"  OK
[HQLTest.testCollectionFunctionsInSelect]
"select baz, size(baz.stringSet), count( distinct elements(baz.stringSet) ), max( elements(baz.stringSet) ) from Baz baz group by baz"  OK
"select elements(fum1.friends) from org.hibernate.test.legacy.Fum fum1"  OK
"select elements(one.manies) from org.hibernate.test.legacy.One one"  OK
[HQLTest.testNamedParameters]
"from Animal an where an.mother.bodyWeight > :weight"  OK
[HQLTest.testClassProperty]
"from Animal a where a.mother.class = Reptile"  OK
[HQLTest.testComponent]
"from Human h where h.name.first = 'Gavin'"  OK
[HQLTest.testSelectEntity]
"select an from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight"  OK
"select mo, an from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight"  OK
[HQLTest.testValueAggregate]
"select max(p), min(p) from User u join u.permissions p"  OK
[HQLTest.testAggregation]
"select count(an) from Animal an"  OK
"select count(distinct an) from Animal an"  OK
"select count(distinct an.id) from Animal an"  OK
"select count(all an.id) from Animal an"  OK
[HQLTest.testSelectProperty]
"select an.bodyWeight, mo.bodyWeight from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight"  OK
[HQLTest.testSelectEntityProperty]
"select an.mother from Animal an"  OK
"select an, an.mother from Animal an"  OK
[HQLTest.testSelectDistinctAll]
"select distinct an.description, an.bodyWeight from Animal an"  OK
"select all an from Animal an"  OK
[HQLTest.testSelectAssociatedEntityId]
"select an.mother.id from Animal an"  OK
[HQLTest.testGroupBy]
"select an.mother.id, max(an.bodyWeight) from Animal an group by an.mother.id having max(an.bodyWeight)>1.0"  OK
[HQLTest.testGroupByMultiple]
"select s.id, s.count, count(t), max(t.date) from org.hibernate.test.legacy.Simple s, org.hibernate.test.legacy.Simple t where s.count = t.count group by s.id, s.count order by s.count"  OK
[HQLTest.testManyToMany]
"from Human h join h.friends f where f.nickName = 'Gavin'"  OK
"from Human h join h.friends f where f.bodyWeight > 100"  OK
[HQLTest.testManyToManyElementFunctionInWhere]
"from Human human where human in elements(human.friends)"  OK
"from Human human where human = some elements(human.friends)"  OK
[HQLTest.testManyToManyElementFunctionInWhere2]
"from Human h1, Human h2 where h2 in elements(h1.family)"  OK
"from Human h1, Human h2 where 'father' in indices(h1.family)"  OK
[HQLTest.testManyToManyFetch]
"from Human h left join fetch h.friends"  OK
[HQLTest.testManyToManyIndexAccessor]
"select c from ContainerX c, Simple s where c.manyToMany[2] = s"  OK
"select s from ContainerX c, Simple s where c.manyToMany[2] = s"  OK
"from ContainerX c, Simple s where c.manyToMany[2] = s"  OK
[HQLTest.testSelectNew]
"select new Animal(an.description, an.bodyWeight) from Animal an"  OK
"select new org.hibernate.test.hql.Animal(an.description, an.bodyWeight) from Animal an"  OK
[HQLTest.testSimpleCorrelatedSubselect]
"from Animal a where a.bodyWeight = (select o.bodyWeight from a.offspring o)"  OK
"from Animal a where a = (from a.offspring o)"  OK
[HQLTest.testSimpleUncorrelatedSubselect]
"from Animal a where a.bodyWeight = (select an.bodyWeight from Animal an)"  OK
"from Animal a where a = (from Animal an)"  OK
[HQLTest.testSimpleCorrelatedSubselect2]
"from Animal a where a = (select o from a.offspring o)"  OK
"from Animal a where a in (select o from a.offspring o)"  OK
[HQLTest.testSimpleUncorrelatedSubselect2]
"from Animal a where a = (select an from Animal an)"  OK
"from Animal a where a in (select an from Animal an)"  OK
[HQLTest.testUncorrelatedSubselect2]
"from Animal a where a.bodyWeight = (select max(an.bodyWeight) from Animal an)"  OK
[HQLTest.testCorrelatedSubselect2]
"from Animal a where a.bodyWeight > (select max(o.bodyWeight) from a.offspring o)"  OK
[HQLTest.testManyToManyJoinInSubselect]
"select foo from Foo foo where foo in (select elt from Baz baz join baz.fooArray elt)"  OK
[HQLTest.testImplicitJoinInSubselect]
"from Animal a where a = (select an.mother from Animal an)"  OK
"from Animal a where a.id = (select an.mother.id from Animal an)"  OK
[HQLTest.testManyToOneSubselect]
"from Animal a where 'foo' in (select m.description from a.mother m)"  OK
[HQLTest.testPositionalParameters]
"from Animal an where an.bodyWeight > ?"  OK
[HQLTest.testKeywordPropertyName]
"from Glarch g order by g.order asc"  OK
"select g.order from Glarch g where g.order = 3"  OK
[HQLTest.testJavaConstant]
"from org.hibernate.test.legacy.Category c where c.name = org.hibernate.test.legacy.Category.ROOT_CATEGORY"  OK
"from org.hibernate.test.legacy.Category c where c.id = org.hibernate.test.legacy.Category.ROOT_ID"  OK
"from Category c where c.name = Category.ROOT_CATEGORY"  OK
"select c.name, Category.ROOT_ID from Category as c"  OK
[HQLTest.testClassName]
"from Zoo zoo where zoo.class = PettingZoo"  OK
"from DomesticAnimal an where an.class = Dog"  OK
[HQLTest.testSelectDialectFunction]
"select mod(s.count, 2) from org.hibernate.test.legacy.Simple as s where s.id = 10"  OK
"select upper(human.name.first) from Human human"  OK
"from Human human where lower(human.name.first) like 'gav%'"  OK
"select max(a.bodyWeight) from Animal a"  OK
[HQLTest.testTwoJoins]
"from Human human join human.friends, Human h join h.mother"  OK
"from Human human join human.friends f, Animal an join an.mother m where f=m"  OK
"from Baz baz left join baz.fooToGlarch, Bar bar join bar.foo"  OK
[HQLTest.testToOneToManyManyJoinSequence]
"from Dog d join d.owner h join h.friends f where f.name.first like 'joe%'"  OK
[HQLTest.testToOneToManyJoinSequence]
"from Animal a join a.mother m join m.offspring"  OK
"from Dog d join d.owner m join m.offspring"  OK
"from Animal a join a.mother m join m.offspring o where o.bodyWeight > a.bodyWeight"  OK
[HQLTest.testSubclassExplicitJoin]
"from DomesticAnimal da join da.owner o where o.nickName = 'gavin'"  OK
"from DomesticAnimal da join da.owner o where o.bodyWeight > 0"  OK
[HQLTest.testMultipleExplicitCollectionJoins]
"from Animal an inner join an.offspring os join os.offspring gc"  OK
"from Animal an left outer join an.offspring os left outer join os.offspring gc"  OK
[HQLTest.testSelectDistinctComposite]
"select distinct p from org.hibernate.test.compositeelement.Parent p join p.children c where c.name like 'Child%'"  OK
[HQLTest.testDotComponent]
"select fum.id from org.hibernate.test.legacy.Fum as fum where not fum.fum='FRIEND'"  OK
[HQLTest.testOrderByCount]
"from Animal an group by an.zoo.id order by an.zoo.id, count(*)"  OK
[HQLTest.testHavingCount]
"from Animal an group by an.zoo.id having count(an.zoo.id) > 1"  OK
[HQLTest.selectWhereElements]
"select foo from Foo foo, Baz baz where foo in elements(baz.fooArray)"  OK
[HQLTest.testCollectionOfComponents]
"from Baz baz inner join baz.components comp where comp.name='foo'"  OK
[HQLTest.testOneToOneJoinedFetch]
"from org.hibernate.test.onetoone.joined.Person p join fetch p.address left join fetch p.mailingAddress"  OK
[HQLTest.testSubclassImplicitJoin]
"from DomesticAnimal da where da.owner.nickName like 'Gavin%'"  OK
"from DomesticAnimal da where da.owner.nickName = 'gavin'"  OK
"from DomesticAnimal da where da.owner.bodyWeight > 0"  OK
[HQLTest.testComponent2]
"from Dog dog where dog.owner.name.first = 'Gavin'"  OK
[HQLTest.testOneToOne]
"from User u where u.human.nickName='Steve'"  OK
"from User u where u.human.name.first='Steve'"  OK
[HQLTest.testSelectClauseImplicitJoin]
"select d.owner.mother from Dog d"  OK
"select d.owner.mother.description from Dog d"  OK
"select d.owner.mother from Dog d, Dog h"  OK
[HQLTest.testFromClauseImplicitJoin]
"from DomesticAnimal da join da.owner.mother m where m.bodyWeight > 10"  OK
[HQLTest.testImplicitJoinInFrom]
"from Human h join h.mother.mother.offspring o"  OK
[HQLTest.testDuplicateImplicitJoinInSelect]
"select an.mother.bodyWeight from Animal an join an.mother m where an.mother.bodyWeight > 10"  OK
"select an.mother.bodyWeight from Animal an where an.mother.bodyWeight > 10"  OK
"select an.mother from Animal an where an.mother.bodyWeight is not null"  OK
"select an.mother.bodyWeight from Animal an order by an.mother.bodyWeight"  OK
[HQLTest.testSelectProperty2]
"select an, mo.bodyWeight from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight"  OK
"select an, mo, an.bodyWeight, mo.bodyWeight from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight"  OK
[HQLTest.testSubclassWhere]
"from PettingZoo pz1, PettingZoo pz2 where pz1.id = pz2.id"  OK
"from PettingZoo pz1, PettingZoo pz2 where pz1.id = pz2"  OK
"from PettingZoo pz where pz.id > 0 "  OK
[HQLTest.testNestedImplicitJoinsInSelect]
"select foo.foo.foo.foo.string from org.hibernate.test.legacy.Foo foo where foo.foo.foo = 'bar'"  OK
"select foo.foo.foo.foo.string from org.hibernate.test.legacy.Foo foo"  OK
[HQLTest.testNestedComponent]
"from org.hibernate.test.legacy.Foo foo where foo.component.subcomponent.name='bar'"  OK
[HQLTest.testNull2]
"from Human h where not( h.nickName is null )"  OK
"from Human h where not( h.nickName is not null )"  OK
[HQLTest.testUnknownFailureFromMultiTableTest]
"from Lower s where s.yetanother.name='name'"  OK
[HQLTest.testJoinInSubselect]
"from Animal a where a in (select m from Animal an join an.mother m)"  OK
"from Animal a where a in (select o from Animal an join an.offspring o)"  OK
[HQLTest.testJoinedSubclassImplicitJoin]
"from org.hibernate.test.legacy.Lower s where s.yetanother.name='name'"  OK
[HQLTest.testProjectProductJoinedSubclass]
"select zoo from Zoo zoo, PettingZoo pz where zoo=pz"  OK
"select zoo, pz from Zoo zoo, PettingZoo pz where zoo=pz"  OK
[HQLTest.testCorrelatedSubselect1]
"from Animal a where exists (from a.offspring o where o.bodyWeight>10)"  OK
[HQLTest.testOuterAliasInSubselect]
"from Human h where h = (from Animal an where an = h)"  OK
[HQLTest.testFetch]
"from Zoo zoo left join zoo.mammals"  OK
"from Zoo zoo left join fetch zoo.mammals"  OK
[HQLTest.testOneToManyElementFunctionInWhere]
"from Zoo zoo where 'dog' in indices(zoo.mammals)"  OK
"from Zoo zoo, Dog dog where dog in elements(zoo.mammals)"  OK
[HQLTest.testManyToManyElementFunctionInSelect]
"select elements(zoo.mammals) from Zoo zoo"  OK
"select indices(zoo.mammals) from Zoo zoo"  OK
[HQLTest.testManyToManyInJoin]
 "select x.id from Human h1 join h1.family x"   OK
"select index(h2) from Human h1 join h1.family h2"  OK
[HQLTest.testManyToManyInSubselect]
 "from Human h1, Human h2 where h2 in (select x.id from h1.family x)"  OK
[HQLTest.testOneToManyIndexAccess]
 "from Zoo zoo where zoo.mammals['dog'] is not null"  OK
[HQLTest.testImpliedSelect]
 "select zoo from Zoo zoo"  OK
 "from Zoo zoo"  OK
 "from Zoo zoo join zoo.mammals m"  OK
 "from Zoo"  OK
 "from Zoo zoo join zoo.mammals"  OK
[HQLTest.testVectorSubselect]
 "from Animal a where ('foo', 'bar') in (select m.description, m.bodyWeight from a.mother m)"  OK
[HQLTest.testWierdSubselectImplicitJoinStuff]
"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count ) and s.other.count > 0"  OK
[HQLTest.testCollectionsInSelect2]
 "select foo.string from Bar bar left join bar.baz.fooArray foo where bar.string = foo.string"  OK
[HQLTest.testAssociationPropertyWithoutAlias]
"from Animal where zoo is null"  OK
[HQLTest.testComponentNoAlias]
"from Human where name.first = 'Gavin'"  OK
[ASTParserLoadingTest.testComponentNullnessChecks]
"from Human where name is null"  OK
"from Human where name is not null"  OK
"from Human where cast(? as string) is null"  OK
"from Human where ? is null"  OK
[ASTParserLoadingTest.testInvalidCollectionDereferencesFail]
"from Animal a join a.offspring o where o.description = 'xyz'"  OK
"from Animal a join a.offspring o where o.father.description = 'xyz'"  OK
"from Animal a join a.offspring o order by o.description"  OK
"from Animal a join a.offspring o order by o.father.description"  OK
"from Animal a order by a.offspring.description"  OK
"from Animal a order by a.offspring.father.description"  OK
[ASTParserLoadingTest.testExpressionWithParamInFunction]
"from Animal where abs(cast(:x as long) - :y) < 2.0"  OK
"from Animal where abs(:x - cast(:y as long)) < 2.0"  OK
"from Animal where abs(cast(:x as long) - cast(:y as long)) < 2.0"  OK
"from Animal where abs(:x - :y) < 2.0"  OK
"from Animal where lower(upper(cast(:foo as string))) like 'f%'"  OK 			
"from Animal where lower(upper(:foo)) like 'f%'"  OK
"from Animal a where abs(abs(a.bodyWeight - 1.0 + :param) * abs(length('ffobar')-3)) = 3.0"  OK 
"from Animal where lower(upper('foo') || upper(cast(:bar as string))) like 'f%'"  OK
"from Animal where lower(upper('foo') || upper(:bar)) like 'f%'"  OK
"from Animal where abs(cast(1 as float) - cast(:param as float)) = 1.0"  OK
[ASTParserLoadingTest.testCrazyIdFieldNames]
"select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e"  OK
[ASTParserLoadingTest.testImplicitJoinsInDifferentClauses]
"select e.owner from SimpleAssociatedEntity e"  OK
"select e.id, e.owner from SimpleAssociatedEntity e"  OK
"from SimpleAssociatedEntity e order by e.owner"  OK
"select e.owner.id, count(*) from SimpleAssociatedEntity e group by e.owner"  OK
[ASTParserLoadingTest.testNestedComponentIsNull]
"from Commento c where c.marelo.commento.mcompr is null"  OK
[ASTParserLoadingTest.testSpecialClassPropertyReference]
"select a.description from Animal a where a.class = Mammal"  OK
"select a.class from Animal a"  OK
"from Animal an where an.class = Dog"  OK
[ASTParserLoadingTest.testSpecialClassPropertyReferenceFQN]
"from Zoo zoo where zoo.class = org.hibernate.test.hql.PettingZoo"  OK
"select a.description from Animal a where a.class = org.hibernate.test.hql.Mammal"  OK
"from DomesticAnimal an where an.class = org.hibernate.test.hql.Dog"  OK
"from Animal an where an.class = org.hibernate.test.hql.Dog"  OK
[ASTParserLoadingTest.testSubclassOrSuperclassPropertyReferenceInJoinedSubclass]
"from Zoo z join z.mammals as m where m.name.first = 'John'"  OK
"from Zoo z join z.mammals as m where m.pregnant = false"  OK
"select m.pregnant from Zoo z join z.mammals as m where m.pregnant = false"  OK
"from Zoo z join z.mammals as m where m.description = 'tabby'"  OK
"select m.description from Zoo z join z.mammals as m where m.description = 'tabby'"  OK
"select m.name from Zoo z join z.mammals as m where m.name.first = 'John'"  OK
"select m.pregnant from Zoo z join z.mammals as m"  OK
"select m.description from Zoo z join z.mammals as m"  OK
"select m.name from Zoo z join z.mammals as m"  OK
"from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'"  OK
"select da.father from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'"  OK
[ASTParserLoadingTest.testJPAPositionalParameterList]
"from Human where name.last in (?1)"  OK
[ASTParserLoadingTest.testComponentQueries]
"select h.name from Human h"  OK
"from Human h where h.name = h.name"  OK
"from Human h where h.name = :name"  OK
"from Human where name = :name"  OK
"from Human h where :name = h.name"  OK
"from Human h where :name <> h.name"  OK
"from Human h where h.name = ('John', 'X', 'Doe')"  OK
"from Human h where ('John', 'X', 'Doe') = h.name"  OK
"from Human h where ('John', 'X', 'Doe') <> h.name"  OK
"from Human h where ('John', 'X', 'Doe') >= h.name"  OK
"from Human h order by h.name"  OK
[ASTParserLoadingTest.testComponentParameterBinding]
"from Order o where o.customer.name =:name and o.id = :id"  OK
"from Order o where o.id = :id and o.customer.name =:name "  OK
[ASTParserLoadingTest.testAnyMappingReference]
"from PropertySet p where p.someSpecificProperty = :ssp"  OK
[ASTParserLoadingTest.testJdkEnumStyleEnumConstant]
"from Zoo z where z.classification = org.hibernate.test.hql.Classification.LAME"  OK
[ASTParserLoadingTest.testParameterTypeMismatchFailureExpected]
"from Animal a where a.description = :nonstring"  OK
[ASTParserLoadingTest.testMultipleBagFetchesFail]
"from Human h join fetch h.friends f join fetch f.friends fof"  OK
[ASTParserLoadingTest.testCollectionJoinsInSubselect]
"select h.id, h.description from Human h left join h.friends where h in ( select h1 from Human h1 left join h1.friends f where h1.id=1)"  OK
"select h.id, h.description from Human h left join h.friends f where f in ( select h1 from Human h1 left join h1.friends f1 where h = f1 )"  OK
[ASTParserLoadingTest.testCollectionFetchWithDistinctionAndLimit]
"select distinct p from Animal p inner join fetch p.offspring"  OK
"select p from Animal p inner join fetch p.offspring order by p.id"  OK
[ASTParserLoadingTest.testFetchInSubqueryFails]
"from Animal a where a.mother in (select m from Animal a1 inner join a1.mother as m join fetch m.mother)"  OK
[ASTParserLoadingTest.testQueryMetadataRetrievalWithFetching]
"from Animal a inner join fetch a.mother"  OK
[ASTParserLoadingTest.testSuperclassPropertyReferenceAfterCollectionIndexedAccess]
"from Zoo zoo where zoo.mammals['tiger'].mother.bodyWeight > 3.0f"  OK
[ASTParserLoadingTest.testJoinFetchCollectionOfValues]
"select h from Human as h join fetch h.nickNames"  OK
[ASTParserLoadingTest.testIntegerLiterals]
"from Foo where long = 1"  OK
"from Foo where long = 1L"  OK
[ASTParserLoadingTest.testDecimalLiterals]
"from Animal where bodyWeight > 100.0e-10"  OK
"from Animal where bodyWeight > 100.0E-10"  OK
"from Animal where bodyWeight > 100.001f"  OK
"from Animal where bodyWeight > 100.001F"  OK
"from Animal where bodyWeight > 100.001d"  OK
"from Animal where bodyWeight > 100.001D"  OK
"from Animal where bodyWeight > .001f"  OK
"from Animal where bodyWeight > 100e-10"  OK
"from Animal where bodyWeight > .01E-10"  OK
"from Animal where bodyWeight > 1e-38"  OK
[ASTParserLoadingTest.testNakedPropertyRef]
"from Animal where bodyWeight = bodyWeight"  OK
"select bodyWeight from Animal"  OK
"select max(bodyWeight) from Animal"  OK
[ASTParserLoadingTest.testNakedComponentPropertyRef]
"select name from Human"  OK
"select upper(h.name.first) from Human as h"  OK
"select upper(name.first) from Human"  OK
[ASTParserLoadingTest.testNakedImplicitJoins]
"from Animal where mother.father.id = 1"  OK
[ASTParserLoadingTest.testNakedEntityAssociationReference]
"from Animal where mother = :mother"  OK
[ASTParserLoadingTest.testNakedMapIndex]
"from Zoo where mammals['dog'].description like '%black%'"  OK
[ASTParserLoadingTest.testInvalidFetchSemantics]
"select mother from Human a left join fetch a.mother mother"  OK
[ASTParserLoadingTest.testArithmetic]
"select 2*2*2*2*(2*2) from Zoo"  OK
"select 2 / (1+1) from Zoo"  OK
"select 2 - (1+1) from Zoo"  OK
"select 2 - 1 + 1 from Zoo"  OK
"select 2 * (1-1) from Zoo"  OK
"select 4 / (2 * 2) from Zoo"  OK
"select 4 / 2 * 2 from Zoo"  OK
"select 2 * (2/2) from Zoo"  OK
"select 2 * (2/2+1) from Zoo"  OK
[ASTParserLoadingTest.testNestedCollectionFetch]
"from Animal a left join fetch a.offspring o left join fetch o.offspring where a.mother.id = 1 order by a.description"  OK
"from Zoo z left join fetch z.animals a left join fetch a.offspring where z.name ='MZ' order by a.description"  OK
"from Human h left join fetch h.pets a left join fetch a.offspring where h.name.first ='Gavin' order by a.description"  OK
[ASTParserLoadingTest.testSelectClauseSubselect]
"select (select max(z.id) from a.zoo z) from Animal a"  OK
"select (select max(z.id) from a.zoo z where z.name=:name) from Animal a"  OK
[ASTParserLoadingTest.testInitProxy]
"from Animal a"  OK
[ASTParserLoadingTest.testSelectClauseImplicitJoin]
"select distinct a.zoo from Animal a where a.zoo is not null"  OK
[ASTParserLoadingTest.testComponentOrderBy]
"from Human as h order by h.name"  OK
[ASTParserLoadingTest.testCastInSelect]
"select cast(bodyWeight as integer) from Animal"  OK
"select cast(a.bodyWeight as integer) from Animal a"  OK
[ASTParserLoadingTest.testAliases]
"select a.bodyWeight as abw, a.description from Animal a"  OK
"select count(*), avg(a.bodyWeight) as avg from Animal a"  OK
[ASTParserLoadingTest.testParameterMixing]
"from Animal a where a.description = ? and a.bodyWeight = ? or a.bodyWeight = :bw"  OK
[ASTParserLoadingTest.testOrdinalParameters]
"from Animal a where a.description = ? and a.bodyWeight = ?"  OK
"from Animal a where a.bodyWeight in (?, ?)"  OK
[ASTParserLoadingTest.testIndexParams]
"from Zoo zoo where zoo.mammals[:name] = :id"  OK
"from Zoo zoo where zoo.mammals[:name].bodyWeight > :w"  OK
"from Zoo zoo where zoo.animals[:sn].mother.bodyWeight < :mw"  OK
"from Zoo zoo where zoo.animals[:sn].description like :desc and zoo.animals[:sn].bodyWeight > :wmin and zoo.animals[:sn].bodyWeight < :wmax"  OK
"from Human where addresses[:type].city = :city and addresses[:type].country = :country"  OK
[ASTParserLoadingTest.testAggregation]
"select sum(h.bodyWeight) from Human h"  OK
"select avg(h.height) from Human h"  OK
"select max(a.id) from Animal a"  OK
[ASTParserLoadingTest.testSelectClauseCase]
"select case nickName when 'Oney' then 'gavin' when 'Turin' then 'christian' else nickName end from Human"  OK
"select case when bodyWeight > 100 then 'fat' else 'skinny' end from Human"  OK
[ASTParserLoadingTest.testImplicitPolymorphism]
"from java.lang.Comparable"  OK
"from java.lang.Object"  OK
[ASTParserLoadingTest.testCoalesce]
"from Human h where coalesce(h.nickName, h.name.first, h.name.last) = 'max'"  OK
"select nullif(nickName, '1e1') from Human"  OK
[ASTParserLoadingTest.testStr]
"select str(an.bodyWeight) from Animal an where str(an.bodyWeight) like '%1%'"  OK
"select str(an.bodyWeight, 8, 3) from Animal an where str(an.bodyWeight, 8, 3) like '%1%'"  OK
"select str(current_date) from Animal"  OK
"select str(year(current_date))||'-'||str(month(current_date))||'-'||str(day(current_date)) from Animal"  OK
[ASTParserLoadingTest.testCast]
"from Human h where h.nickName like 'G%'"  OK
"from Animal a where cast(a.bodyWeight as string) like '1.%'"  OK
"from Animal a where cast(a.bodyWeight as integer) = 1"  OK
[ASTParserLoadingTest.testExtract]
"select second(current_timestamp()), minute(current_timestamp()), hour(current_timestamp()) from Mammal m"  OK
"select day(m.birthdate), month(m.birthdate), year(m.birthdate) from Mammal m"  OK
"select extract(second from current_timestamp()), extract(minute from current_timestamp()), extract(hour from current_timestamp()) from Mammal m"  OK
"select extract(day from m.birthdate), extract(month from m.birthdate), extract(year from m.birthdate) from Mammal m"  OK
[ASTParserLoadingTest.testSelectExpressions]
"select 'found', lower(h.name.first) from Human h where lower(h.name.first) = 'gavin'"  OK
"select 'found', lower(h.name.first) from Human h where concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) = 'Gavin A King'"  OK
"select 'found', lower(h.name.first) from Human h where h.name.first||' '||h.name.initial||' '||h.name.last = 'Gavin A King'"  OK
"select a.bodyWeight + m.bodyWeight from Animal a join a.mother m"  OK
"select 2.0 * (a.bodyWeight + m.bodyWeight) from Animal a join a.mother m"  OK
"select sum(a.bodyWeight + m.bodyWeight) from Animal a join a.mother m"  OK
"select sum(a.mother.bodyWeight * 2.0) from Animal a"  OK
"select concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) from Human h"  OK
"select h.name.first||' '||h.name.initial||' '||h.name.last from Human h"  OK
"select nickName from Human"  OK
"select lower(nickName) from Human"  OK
"select abs(bodyWeight*-1) from Human"  OK
"select upper(h.name.first||' ('||h.nickName||')') from Human h"  OK
"select abs(a.bodyWeight-:param) from Animal a"  OK
"select abs(:param - a.bodyWeight) from Animal a"  OK
"select lower(upper('foo')) from Animal"  OK
"select lower(upper('foo') || upper('bar')) from Animal"  OK
"select sum(abs(bodyWeight - 1.0) * abs(length('ffobar')-3)) from Animal"  OK
[ASTParserLoadingTest.testImplicitJoin]
"from Animal a where a.mother.bodyWeight < 2.0 or a.mother.bodyWeight > 9.0"  OK
"from Animal a where a.mother.bodyWeight > 2.0 and a.mother.bodyWeight > 9.0"  OK
[ASTParserLoadingTest.testSimpleSelect]
"select a.mother from Animal as a"  OK
[ASTParserLoadingTest.testWhere]
"from Animal an where an.bodyWeight > 10"  OK
"from Animal an where not an.bodyWeight > 10"  OK
"from Animal an where an.bodyWeight between 0 and 10"  OK
"from Animal an where an.bodyWeight not between 0 and 10"  OK
"from Animal an where sqrt(an.bodyWeight)/2 > 10"  OK
"from Animal an where (an.bodyWeight > 10 and an.bodyWeight < 100) or an.bodyWeight is null"  OK
[ASTParserLoadingTest.testEntityFetching]
"from Animal an join fetch an.mother"  OK
"select an from Animal an join fetch an.mother"  OK
[ASTParserLoadingTest.testCollectionFetching]
"from Animal an join fetch an.offspring"  OK
"select an from Animal an join fetch an.offspring"  OK
[ASTParserLoadingTest.testProjectionQueries]
"select an.mother.id, max(an.bodyWeight) from Animal an group by an.mother.id"  OK
[ASTParserLoadingTest.testStandardFunctions]
"select current_time(), current_date(), current_timestamp() from Product"  OK
[ASTParserLoadingTest.testDynamicInstantiationQueries]
"select new list(an.description, an.bodyWeight) from Animal an"  OK
"select new map(an.description, an.bodyWeight) from Animal an"  OK
"select new map(an.description as descr, an.bodyWeight as bw) from Animal an"  OK
[ASTParserLoadingTest.testResultTransformerScalarQueries]
"select an.description as description, an.bodyWeight as bodyWeight from Animal an order by bodyWeight desc"  OK
"select a from Animal a, Animal b order by a.id"  OK
[ASTParserLoadingTest.testResultTransformerEntityQueries]
"select an as an from Animal an order by bodyWeight desc"  OK
[ASTParserLoadingTest.testEJBQLFunctions]
"from Animal a where a.description = concat('1', concat('2','3'), '4'||'5')||'0'"  OK
"from Animal a where substring(a.description, 1, 3) = 'cat'"  OK
"from Animal a where lower(a.description) = 'cat'"  OK
"from Animal a where upper(a.description) = 'CAT'"  OK
"select upper(a.description) from Animal a"  OK
"from Animal a where length(a.description) = 5"  OK
"from Animal a where locate('abc', a.description, 2) = 2"  OK
"from Animal a where locate('abc', a.description) = 2"  OK
"select locate('cat', a.description, 2) from Animal a"  OK
"from Animal a where trim(trailing '_' from a.description) = 'cat'"  OK
"from Animal a where trim(leading '_' from a.description) = 'cat'"  OK
"from Animal a where trim(both from a.description) = 'cat'"  OK
"from Animal a where trim(a.description) = 'cat'"  OK
"from Animal a where abs(a.bodyWeight) = sqrt(a.bodyWeight)"  OK
"from Animal a where mod(16, 4) = 4"  OK
"from Animal a where bit_length(a.bodyWeight) = 24"  OK
"select bit_length(a.bodyWeight) from Animal a"  OK
"from Animal a where a.description like '%a%'"  OK
"from Animal a where a.description not like '%a%'"  OK
"from Animal a where a.description like 'x%ax%' escape 'x'"  OK
[ASTParserLoadingTest.testSubselectBetween]
"from Animal x where (select max(a.bodyWeight) from Animal a) between 0 and 100"  OK
//
"from Animal x where (x.name, x.bodyWeight) = ('cat', 20)"  OK

[DELETE STATEMENT]
"delete Animal where mother is not null"  OK
"delete Animal where not mother is not null"  OK
"delete Animal"  OK
"delete from Thing"  OK
"delete from Person"  OK
"delete from Location"  OK
"delete from Child"  OK
"delete from Parent"  OK
"delete from Item"  OK
"delete Customer where contactOwner is not null"  OK
"delete Employee where manager is not null"  OK
"delete Person"  OK
"delete Locality"  OK
"delete Country"  OK
"delete Continent"  OK
"delete from DataPoint"  OK
"delete from User where userid = :userid"  OK
"delete from Mail where alias = :alias"  OK
"delete from NumberedNode where name like 'child%'"  OK
"delete from fooArray where id_='???' and i>=8"  OK
"delete from t_user"  OK
"delete Animal where not description like 'root%'"  OK
"delete Animal where description like 'grand%'"  OK
"delete from Animal where mother is not null or father is not null"  OK
"delete Animal where mother = :mother"  OK
"delete EntityWithCrazyCompositeKey where id.id = 1 and id.otherId = 2"  OK
"delete from EntityWithCrazyCompositeKey where id.id = 1 and id.otherId = 2"  OK
"delete from EntityWithCrazyCompositeKey e where e.id.id = 1 and e.id.otherId = 2"  OK
"delete from Bar where barString = 's'"  OK
"delete Vehicle where owner = :owner"  OK
"delete Mammal where bodyWeight > 150"  OK
"delete from User u where u not in (select u from User u)"  OK
"delete SimpleEntityWithAssociation e where size( e.associatedEntities ) = 0 and e.name like '%'"  OK
"delete Animal where bodyWeight = null"  OK
"delete from PICKUP"  OK
"delete from Address where id = ? and version = ?"  OK
"delete Address[1]"  FAIL
[UDPATE STATEMENT]
"update Paper set color = :newColor"  OK
"update Document set name = :newName where name = :oldName"  OK
"update Mammal set bodyWeight = null"  OK
"update Zoo set address.city = null"  OK
"update PettingZoo set address.city = null"  OK
"update Vehicle set owner = null where owner = 'Steve'"  OK
"update Vehicle set owner = 'Steve'"  OK
"update Mammal set bodyWeight = ( select max(bodyWeight) from Animal )"  OK
"update Mammal set bodyWeight = 25"  OK
"update Mammal set description = description"  OK
"update Animal set bodyWeight = bodyWeight + :w1 + :w2"  OK
"update Animal set description = :newDesc where description = :desc"  OK
"update Animal set description = description where description = :desc"  OK
"update Zoo as z set name = name where id = :id"  OK
"update Zoo as z set z.name = z.name"  OK
"update PettingZoo pz set pz.name = pz.name where pz.id = :id"  OK
"update PettingZoo set name = name"  OK
"update Human set mother.name.initial = :initial"  OK
"update Animal a set a.mother = (from Animal where id = 1) where a.id = 2"  OK
"update Animal a set a.mother = null where a.id = 2"  OK
"update Human set name.first = :correction where id = :id"  OK
"update versioned TimestampVersioned set name = name"  OK
"update versioned IntegerVersioned set name = name"  OK
<<update SimpleEntityWithAssociation e
     set e.name = 'updated'
     where exists (
           select a.id 
           from e.associatedEntities a 
           where a.name = 'one-to-many-association' 
     )>>  OK
<<update SimpleEntityWithAssociation e
     set e.name = 'updated'
     where exists (
     	select a.id
     	from e.manyToManyAssociatedEntities a
     	where a.name = 'many-to-many-association'
 	 )>>  OK
<<update Human h
     set h.description = 'updated' 
     where exists (
     	 select f.id
     	 from h.friends f
     	 where f.name.last = 'Public'
 	 )>>  OK
"update Human set Human.description = 'xyz' where Human.id = 1 and Human.description is null"  OK
"update BooleanLiteralEntity set yesNoBoolean = true, trueFalseBoolean = true, zeroOneBoolean = true"  OK
"update BooleanLiteralEntity set yesNoBoolean = :b1, trueFalseBoolean = :b2, zeroOneBoolean = :b3"  OK
"update NonExistentEntity e set e.someProp = ?"  OK
"update Customer c set c.company = 'XYZ'"  OK
"update User u set u.username = :un where u.name = :n"  OK
"update Person p set p.name = '<male>'"  OK
"update Person p set p.name = 'Shawn'"  OK
"update Address set city = ?, state=?, zip=?, version = ? where id in (select aid from Person)"  OK
"update Address set city = ?, state=?, zip=?, version = ? where id = ? and version = ?  "  OK
[INSERT STATEMENT]
"insert into Simple ( name, address, count_, date_, other, id_ ) values ( ?, ?, ?, ?, ?, ? )"  FAIL
"insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h join h.mother m where m.mother is not null"  OK
"insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h where h.mother.mother is not null"  OK
"insert into TimestampVersioned ( name ) select name from TimestampVersioned"  OK
"insert into IntegerVersioned ( name ) select name from IntegerVersioned"  OK
"insert into PettingZoo (name) select name from Zoo"  OK
"insert into Joiner (name, joinedName) select vin, owner from Car"  OK
"insert into Human (id, bodyWeight) select id, bodyWeight from Lizard"  OK
"insert into Pickup (owner, vin, id) select id, vin, owner from Car"  OK
"insert into Animal (description, bodyWeight, mother) select description, bodyWeight, mother from Human"  OK
"insert into PICKUP (id, vin, owner) select id, vin, owner from Car"  OK
"insert into Pickup (id, vin, owner) select id, vin, owner from Car"  OK
"insert into Address (city, state, zip, \"from\") values (?, ?, ?, 'insert value')"  FAIL
"insert Address"  FAIL
"insert a.b.c.Address"  FAIL

/*
filterStatement:
"order by this.id"  OK
"where this.name = ?"  OK
"where this.quantity > :quantity"  OK
"where this.bodyWeight > ?"  OK
"where this.bodyWeight < ?"  OK
*/